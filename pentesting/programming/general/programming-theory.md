# Programming Theory

## Programming Language Level

Programming encompasses many concepts, categorizations and hierarchies. In this section we'll provide a general overview well-suited to penetration testing.

All programming languages are either _compiled_ or _interpreted_. When using a compiled language, code must be converted to binary (compiled) before it can be executed. On the other hand, when using an interpreted language, code files (_scripts_) are parsed and converted into the required binary format one line at a time when executed.

In order to describe the hierarchy of programming languages we'll focus on compiled languages and begin with a discussion of the lowest-level languages.

Low-level programming languages are difficult for humans to understand, and are specifically tied to the hardware and contain a limited amount of features. On the other hand, high-level languages are easier for programmers to read and write, are more portable and provide access to greater complexity through the paradigm of _object-oriented programming_.

At the very core, the CPU performs actions based on the _opcodes_ stemming from the compiled code. An opcode is a binary value which the CPU maps to a specific action. The set of opcodes can be translated to the low level _assembly_ programming language for better human readability.

When we deal with Windows or Linux computers we typically concern ourselves with the _x86 architecture_. The architecture defines which opcodes are valid and what functionality they map to in assembly. The same thing applies to other CPU architectures like _ARM_ which is used with most smartphones and tablets.

Applications that require low overhead and high efficiency such as the core components of an operating system or a browser typically have elements written in assembly. Although we will not often write assembly code as penetration testers, it can be helpful to understand it in order to perform various bypasses of security products or perform more advanced attacks.

When we consider a language such as _C_, we are using a more human-readable syntax, even though _C_ is still considered a relatively low-level language. By contrast, _C++_ can be considered as both high and low-level. It still provides access to all the features of C and accepts directly embedded assembly code through _inline assembly_ instructions. C++ also provides access to high-level features like classes and objects making it an object-oriented programming language.

Most scripting languages like _Python_, _JavaScript_ or _PowerShell_ are high-level languages and make use of the object-oriented programming model as well.

Languages like _Java_ and _C#_ are also object-oriented programming languages but are vastly different in how they are compiled and execute.

Code from Java and C# is compiled into _bytecode_ which is then processed by an installed virtual machine. Java uses the _Java Virtual Machine_ (_JVM_) which is part of the _Java Runtime Environment_ (_JRE_). C# uses the _Common Language Runtime_ (_CLR_), which is part of the _.NET_ framework.

Web browsers typically execute code from scripting languages like JavaScript through a virtual machine as well. But when repetitive tasks are encountered a technique called _just-in-time_ (_JIT_) compilation is employed where the script is compiled directly into native code.

Java's popularity largely stems from its operating system-independence, while C# has been primarily constrained to the Windows platform. With the relatively recent release of _.NET Core_ C# is also available on Linux or macOS.

When the bytecode is executed, the virtual machine compiles it into opcodes which the CPU executes.

In this scenario, a virtual machine will often provide memory management support that can help prevent security vulnerabilities such as buffer overflows.

Although it's not critical to be able to program in each of these languages, as penetration testers we should at least understand their differences and limitations.

## Programming Concepts

In this section we'll discuss some basic concepts and terminology used in high-level language programming.

A key component of object-oriented programming is a _class_ which acts as a template for creating objects. Most classes contain a number of variables to store associated data and _methods_ that can perform actions on the variables.

In the Object-oriented paradigm, an object is _instantiated_ from its class through a special method called _constructor_. Typically the constructor is named after its class and it's mostly used to setup and initialize the instance variables of a class.

For example, in the listing below, when a _MyClass_ object is instantiated, the _MyClass_ constructor will setup and initialize the _myNumber_ class variable to the value passed as a parameter to the constructor.

```csharp
public class MyClass
{
    private int myNumber;

    // constructor
    public MyClass(int aNumber)
    {
        this.myNumber = aNumber;
    }
    
    public getNumber()
    {
      return myNumber;
    }
}
```

As noted in Listing 1, the name of class, method and variables are pre-pended by an _access modifier_. The two most common are _public_ and _private_. The _public_ modifier allows both code outside the class and inside the class to reference and use it, while _private_ only allows code inside the class to access it. The same concept applies for methods.

In Listing 1, all code can call the constructor _MyClass_, but only the instantiated object can reference the variable _myNumber_ directly. Code outside the object has to call the public method _getNumber_ to evaluate _myNumber_.

As we begin developing attack techniques and begin to write custom code, these concepts and terms will become increasingly more important. In addition, we'll rely on these concepts as we investigate and reverse-engineer high-level code.
