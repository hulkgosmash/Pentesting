# Signed vs Unsigned Numbers

## Summary

Imagine we have four bytes (the size of an integer in C) to store a number. If we don't want to store negative numbers, our range extends from 0 to 4,294,967,295 (2^32 − 1). If we want to store the largest possible value, 0xffffffff, we need to treat the number as a positive number, which is typically achieved by defining it as _unsigned_.

If, however, we also want to be able store a negative number, we need to use a _signed_ number. When we do that, our range is split into two and ranges from −2,147,483,648 to 2,147,483,647 (−(2^31) to 2^31 − 1). The reason for the smaller range is that we need to store the signage information, whether negative or positive, in 1 bit. The most significant bit is used for signage, and if it's set, we know it's a negative number.

Next, we need to understand how negative numbers are formed. First, negative numbers are stored in _two's complements form_ using a simple calculation. We start with the positive equivalent of the number, invert all bits, and add 1 at the end. Below is an example of converting 42 to -42.

```
42:     0000 0000 0000 0000 0000 0000 0010 1010
Invert: 1111 1111 1111 1111 1111 1111 1101 0101
Add +1: 1111 1111 1111 1111 1111 1111 1101 0110
```

42 is 0x2a in hexadecimal format, and its bit representation is shown in Listing 1. First we convert each bit, then add 1 at the end, resulting in 0xffffffd6.

Another way to consider this: the bitmask is a circular counter, so by moving in a negative direction, we need to rotate all bits after 0, resulting in 0xffffffff, or "-1". For -2, we subtract 1, resulting in 0xfffffffe, and so on.

Next we will discuss CPU registers and their use.

## Conversion

{% embed url="https://www.mathsisfun.com/binary-decimal-hexadecimal-converter.html" %}
