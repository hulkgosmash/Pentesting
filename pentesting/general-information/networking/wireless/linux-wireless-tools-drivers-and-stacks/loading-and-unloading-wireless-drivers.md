# Loading and Unloading Wireless Drivers

Let's start with the basics and configure our wireless device with command line tools.

When a device is plugged in or powered on, Linux should automatically load its driver. Let's type the airmon-ng command in the command prompt to determine our device's driver. Airmon-ng is a utility from the Aircrack-ng suite of tools for auditing Wi-Fi networks.

```bash
sudo airmon-ng
```

The output reveals the wireless device's driver as ath9k\_htc and its chipset as Qualcomm Atheros AR9271.

Next, let's run the lsusb command. This command lists a system's USB devices and shows detailed information for each device:

```bash
sudo lsusb -vv
```

This excerpt from the output indicates the vendor id and product id are 0cf3:9271 and the chipset is a AR9271 from Qualcomm Atheros Communications.

In Windows, each and every piece of hardware needs to have its own driver installed. Some devices are very similar. They may have identical chips or different chips that behave similarly. It may even be the case that two devices that look alike will advertise different product IDs.

On Linux, one driver can cover multiple devices, and sometimes multiple similar chipsets. For example, the Alfa AWUS036NHA has the same chipset as the TP-Link WN722N v1 as well as at least 50 other devices, which means a single driver handles them all. Because that specific driver is provided with the kernel, nothing needs to be installed.

While it is possible to build drivers in the kernel itself in Linux, most drivers are usually Loadable Kernel Modules (LKM), which are only loaded when necessary to avoid wasting memory. Other operating systems use loadable kernel modules as well, but name the feature differently.

While it is rarely necessary to change them, kernel modules often have parameters to adjust settings of the hardware. These settings are displayed with the _modinfo_ command and the name of the driver. Running modinfo for the ath9k\_htc driver displays the following output:

```bash
sudo modinfo ath9k_htc
```

This information is important for determining dependencies, compatibility, and firmware requirements. The full path of the ath9k\_htc.ko driver file is displayed in the _filename_ field. Drivers are located in subdirectories of /lib/modules/\<kernel version>. This is consistent with the _vermagic_ field indicating this driver was compiled for 4.16.0-kali2-amd64.

The two _firmware_ fields indicate both ath9k\_htc/htc\_9271-1.4.0.fw and ath9k\_htc/htc\_7010-1.4.0.fw firmwares can be loaded by this driver.

The driver lists all the device aliases it supports in the _alias_ fields. For instance, usb:v0CF3p9271 indicates a USB device, manufactured by vendor ID 0CF3 (Qualcomm Atheros Communications), with device ID 9271 (AR9271 802.11n). So when the device is installed, it identifies itself as usb:v0CF3p9271 and when the system determines the ath9k\_htc driver supports that alias, it gets loaded in memory.

When the driver is loaded in memory, the system also loads the dependent modules listed in the _depends_ field. If the listed modules also have dependencies, those modules are loaded as well.

The items in the _params_ field are options for the device. Typically, we don't need to change the default parameters. Linux distributions may do so if they see fit.

In the following example, we will disable blinking on network activity on the ath9k\_htc driver, by resetting the _blink_ parameter when loading the driver:

```bash
sudo modprobe ath9k_htc blink=0
```

If an error occurs, it will be displayed in the console. If there is no error, there will be no output.

Linux distributions allow users to set and change parameters for modules using /etc/modprobe.d. This directory can also be used to blacklist modules.

A good example of when to use blacklisting would be the case where an open source Broadcom driver and the closed source vendor drivers are both present on the system. If we run modinfo on both of them, we will see they share similar IDs. There should only be one driver claiming a device at a time, so we have to blacklist one of them. If we don't, the two drivers will fight for the same resource, causing unexpected results.

lsmod lists all the loaded modules as well as the dependencies of each module. Running the command with the ath9k\_htc driver loaded outputs the following:

```bash
lsmod
```

Notice the lsmod output relevant to our wireless driver corresponds with our modinfo dependencies in Listing 3. The first column has the loaded module and the third column shows the number of, and names, of the modules using it.

Sometimes it is necessary to unload a driver. At times we need to reload it (with or without different parameters) or we may want to use a different driver since only one driver can claim a device at a time.

Before unloading a driver, we need to remove the modules the device is dependent on with the rmmod command. Modules dependent on the main module(s) must be unloaded first.

Let's examine what happens if we try to remove a module for our ath9k\_htc driver that has remaining dependencies:

```bash
sudo rmmod ath
```

Listing 6 shows that trying to remove a module with dependencies returns an error.

With our lsmod output in Listing 5 as a guide, we can start removing modules that are not needed by other drivers. If we are unsure which module to remove next, we can run lsmod again and find one that isn't used by any other.

```bash
sudo rmmod ath9k_htc ath9k_common ath9k_hw ath
```
