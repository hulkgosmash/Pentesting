# 2. WinDbg and x86 Architecture

## Introduction to x86 Architecture

### Program Memory

When a binary application is executed, it allocates memory in a very specific way within the memory boundaries used by modern computers. Figure 1 shows how process memory is allocated in the Windows between the lowest memory address (0x00000000) and the highest memory address (0x7FFFFFFF) used by applications.&#x20;

<figure><img src="../../../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

#### The stack

When a thread is running, it executes code from within the Program Image or from various Dynamic Link Libraries (DLLs). The thread requires a short-term data area for functions, local variables, and program control. information, which is known as the stack. To facilitate the independent execution of multiple threads, each thread in a running application has its own stack.&#x20;

Stack memory is "viewed" by the CPU using a Last-In, First-Out (LIFO) structure. This essentially means that while accessing the stack, items put ("pushed") on the top of the stack are removed ("popped") first. The x86 architecture implements dedicated PUSH and POP assembly instructions to add or remove data to the stack respectively.&#x20;

### Calling conventions

Calling conventions describe how functions receive their parameters from their caller and how they return the result. The x86 architecture allows for the use of multiple calling conventions. The difference in their implementation consists of several factors such as how the parameters and return value are passed (placed in CPU registers, pushed on the stack, or both). in which order they are passwd, how the stack is prepared and cleaned up before and after the call, and what CPU registers the called function must preserve for the caller.&#x20;

Generally speaking, the compiler determines which calling convention is used for all functions in a program, however, in some cases, it is possible for the programmer to specify a specific calling convention on a per-function basis.&#x20;

#### Function Return Mechanics

When code within a thread calls a function, it must know which address to return to once the function completes. This "return address" (along with the function's parameters and local variables) is stored on the stack. This collection of data is associated with one function call and is stored in a section of the stack memory known as a stack frame. An example of a stack frame is illustrated in Figure 2.&#x20;

<figure><img src="../../../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

When a function ends, the return address is taken from the stack and used to restore the execution flow to the calling function.&#x20;

While we've described the process at a high level, next we must understand more about how this is accomplished at the CPU level. This requires a discussion about CPU registers.&#x20;

### CPU Registers

To perform efficient code execution, the CPU maintains and uses a series of nine 32-bit registers (on a 32-bit architecture). Registers are small, extremely high-speed CPU storage locations where data can be efficiently read or manipulated. These nine registers, including the nomenclature for the higher and lower bits of those registers, are shown in Figure 3.&#x20;



<table><thead><tr><th width="201">32-bit register</th><th width="188">Lower 16 bits</th><th width="212">Higher 8 bits</th><th>Lower 8 bits</th></tr></thead><tbody><tr><td>EAX</td><td>AX</td><td>AH</td><td>AL</td></tr><tr><td>EBC</td><td>BX</td><td>BH</td><td>BL</td></tr><tr><td>ECX</td><td>CX</td><td>CH</td><td>CL</td></tr><tr><td>EDX</td><td>DX</td><td>DH</td><td>DL</td></tr><tr><td>ESI</td><td>SI</td><td>N/A</td><td>N/A</td></tr><tr><td>EDI</td><td>DI</td><td>N/A</td><td>N/A</td></tr><tr><td>EBP</td><td>BP</td><td>N/A</td><td>N/A</td></tr><tr><td>ESP</td><td>SP</td><td>N/A</td><td>N/A</td></tr><tr><td>EIP</td><td>IP</td><td>N/A</td><td>N/A</td></tr></tbody></table>

The register names were established for 166-bit architectures and were then extended with the advent of the 32-bit (x86) platform, hence the letter "E" in the register acronyms. Each register may contain a 32-bit value (allowing values between 0 and 0xFFFFFFFF) or may contain 16-bit or 8-bit values in the respective subregisters, as shown in the EAX register in Figure 4.&#x20;

<figure><img src="../../../../.gitbook/assets/image (157).png" alt=""><figcaption></figcaption></figure>

#### General Purpose Registers

Several registers such as EAX, EBX, ECX, EDX, ESI, and EDI are often used as general purpose registers to store temporary data. There is much more to this discussion (as explained in various online resources), but the primary registers for our purposes are described below:&#x20;

* EAX (accumulator): Arithmetical and logical instructions
* EBX (base): Base pointer for memory addresses
* ECX (counter): Loop, shift and rotation counter
* EDX (data): I/IO port addressing, multiplication, and division
* ESI (source index): Pointer addressing of data and source in string copy operations
* EDI (destination index): Pointer addressing of data and destination in string copy operations

#### ESP - The Stack Pointer

As previously mentioned, the stack is used for storage of data, pointers, and arguments. Since the stack is dynamic and changes constantly during program execution, the stack pointer ESP keeps "track" of the most recently referenced location on the stack (top of the stack) by storing a pointer to it.&#x20;

#### EBP - The Base Pointer

Since the stack is in constant flux during the execution of a thread, it can become difficult for a function to locate its stack frame, which stores the require arguments, local variables, and the return address. EBP, the base pointer, solves this by storing a pointer to the top of the stack when a function is called. By accessing EBP, a function can easily reference information from   its stack frame (via offsets) while executing.&#x20;

#### EIP - The Instruction Pointer

EIP, the instruction pointer, is one of the most important registers for our purposes as it always points to the next code instruction to be executed. Since EIP essentially directs the flow of a program, it is an attacker's primary target when exploiting any memory corruption vulnerability such as a buffer overflow.&#x20;

## Introduction to Windows Debugger

### Debugging Symbols

In settings -> Debugging settings update symbol path to the below.&#x20;

```bash
srv*c:\symbols*https://msdl.microsoft.com/download/symbols
```

Reload debugging symbols (In command window)

```bash
.reload /f
```

## Accessing and Manipulating Memory from WinDbg

### Unassemble from Memory

```bash
u kernel32!GetCurrentThread
```

### Reading from Memory

{% code overflow="wrap" %}
```bash
# Display byte (Shows bytes + ASCII)
db esp
# Display word (Shows Words (2 bytes) no ASCII)
dw esp
# Display DWORDs (two bytes)
dd esp
# Display explicit address
db 00faf974
# Display symbol names
db kernel32!WriteFile
# Display QWORDs
dq 00faf974
# Display ACSII as well with
dc KERNELBASE
dW KERNELBASE+0x40
# Default length when displaying data is 0x80 bytes. We can change this value by using the Lparameter with display commands, as shown below
dd esp L4
dd esp L10
# 2 Words
dW KERNELBASE L2
# 2 Bytes
db KERNELBASE L2
# Display memory address in ASCII
da
# Display memory address in Unicode
du
# Display data through the pointer to data command (poi). Which displays data referenced from a memory address. 
dd esp L1
dd 771bab89
dd poi(esp)
```
{% endcode %}

### Dumping Structures from Memory

{% code overflow="wrap" %}
```bash
# The Display Type dt26 command takes the name of the structure to display as an argument and, optionally, a memory address from which to dump the structure data.
dt ntdll!_TEB
# Recursively display nested structures
dt -r ntdll!_TEB @$teb
# Display specific fields in the structure by passing the name of the field as an additional parameter.
dt ntdll!_TEB @$teb ThreadLocalStoragePointer
# WinDbg can also display the size of a structure extracted from a symbol file. 
?? sizeof(ntdll!_TEB)

```
{% endcode %}

### Writing to Memory

#### Cheat sheet

| Command | Enter                                                                                                                                                                                                            |
| ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **e**   | This enters data in the same format as the most recent **e** _command. (If the most recent **e**_ command was **ea**, **eza**, **eu**, or **ezu**, the final parameter will be _String_ and may not be omitted.) |
| **ea**  | ASCII string (not NULL-terminated).                                                                                                                                                                              |
| **eb**  | Byte values.                                                                                                                                                                                                     |
| **ed**  | Double-word values (4 bytes).                                                                                                                                                                                    |
| **eD**  | Double-precision floating-point numbers (8 bytes).                                                                                                                                                               |
| **ef**  | Single-precision floating-point numbers (4 bytes).                                                                                                                                                               |
| **ep**  | Pointer-sized values. This command is equivalent to **ed** or **eq**, depending on whether the target computer's processor architecture is 32-bit or 64-bit, respectively.                                       |
| **eq**  | Quad-word values (8 bytes).                                                                                                                                                                                      |
| **eu**  | Unicode string (not NULL-terminated).                                                                                                                                                                            |
| **ew**  | Word values (2 bytes).                                                                                                                                                                                           |
| **eza** | NULL-terminated ASCII string.                                                                                                                                                                                    |
| **ezu** | NULL-terminated Unicode string.                                                                                                                                                                                  |

```bash
# Editing a DWORD directory
# Display the contents of ESP
dd esp L1
003cb710 00000000
# Edit ESP to be all 'A'
ed esp 41414141
# Display the modified contents of ESP
dd esp L1
003cb710 41414141

# Editing in ASCII or Unicode use EA (ASCII) or EU (Unicode)
# Display the contents of ESP
da esp
003cb710 ""
# Edit ESP to be 'Hello'
ea esp "Hello"
# Display the contents of ESP
da esp
003cb710 "Hello"
```

### Searching the Memory Space

#### Cheat sheet

Basic Format

```
s -<type> <searching address (starts at 0)> <memory range> <what to search>
s -d 0 L?80000000 41414141
```

_Type_\
Specifies the memory type to search for. Add a hyphen (-) in front of _Type_ . You can use one of the following _Type_ values.

| Type  | Description                                               |
| ----- | --------------------------------------------------------- |
| **b** | Byte (8 bits)                                             |
| **w** | WORD (16 bits)                                            |
| **d** | DWORD (32 bits)                                           |
| **q** | QWORD (64 bits)                                           |
| **a** | ASCII string (not necessarily a null-terminated string)   |
| **u** | Unicode string (not necessarily a null-terminated string) |

In WinDbg, we can search the debugged process memory space by using the **s** command

```bash
# Edit the ESP and put the value '41414141' there
ed esp 41414141
# Search for DWORD (-d) set searching address to start at 0 search whole range.
s -d 0 L?80000000 41414141
# Search for an ASCII string
s -a 0 L?80000000 "This program cannot be run in DOS mode"

```

### Inspecting and Editing CPU Registers in WinDbg

Access registers using the **r** command

```bash
# Dump all registers
r
# Dump ecx register
r ecx
# Modify the ECX register
r ecx=41414141
```

## Controlling the Program Execution in WinDbg

WinDbg can set breakpoints to halt the execution flow at desired locations in the code. There are two different types of breakpoints; software and processor / hardware breakpoints.&#x20;

Breakpoints controlled directly by thhe debugger are known as software breakpoints. Breakpoints controlled by the processor and set through the debugger are known as hardware breakpoints.&#x20;

In the following sectionk, we will experiement with the setting up various software and hardware breakpoints while attached to the notepad.exe process. We will learn how to set software breakpoints at particular Windows APIs, some of which are not yet loaded in the meory space of our application. We will also use hardware breakpoints to determine exactly when our ddata is accessed.&#x20;

### Software Breakpoints

When placing a software breakpoint, WinDbg temporarily replaces the first opcode of the instruction where we want execution to halt with an INT 3 assembly instruction. The advantage of software breakpoints is that we are allowed to set as many as we want.&#x20;

Let's try this out. With WinDbg attached to Notepad, we are going to set a breakpoint that will halt the execution flow of the application when changes are being saved to a file. To do this, we are going to set a breakpoint at the Windows WriteFile API, which is commonly used to write data to a specified file or input / output (I/O) device.&#x20;

```bash
# Set a breakpoint at the Windows WriteFile API
bp kernel32!WriteFile
# List all break points
bl
# Let execution continue
g
# Disable breakpoint 0
bd 0
# Enable breakpoint 0
be 0
# Clear breakpoint 0
bc 0
```

### Unresolved Function Breakpoint

We can use the **bu** command to set a breakpoint on an unresolved function. This is a function residing in a module that isn't yet loaded in the process memory space. In this caser, the breakpoint will be enabled when the module is loaded and the target function is resolved.&#x20;

Here is an example of the bu command applied to Notepad. the module OLE32.dll is not initially loaded in the notepad.exe process, but is loaded once a file is saved. Once WinDbg is attached to the notepad.exe process, we will set an unresolved breakpoint on a arbitrary OLE32 function, **OLE32!WriteStringStream**.&#x20;

```bash
bu ole32!WriteStringStream
```

### Breakpoint-Based Actions

We can also automate the execution of commands within the debugger when a breakpoint is triggered. This enables us to print the register's content, dereference memory location, and perform other powerful actions when a breakpoint is hit.&#x20;

Let's consider the example in Listing 218. WinDbg is attached to Notepad and we want to display the number of bytes writen to a file in the debugger windows. To do this, we can execute the **.printf** command every time the breakpoint set on the kernel32!WQriteFile API is triggered using the syntax show below:&#x20;

{% code overflow="wrap" %}
```bash
bp kernel32!WriteFile ".printf \"The number of bytes written is: %p\", poi(esp + 0x0C);.echo;g"
```
{% endcode %}

Similar to the C/C++ version, **.printf** supports the use of format strings such as **%p**, which will display the given value as a pointer. In our example, the **.echo** command displays the output of **.printf** to the WinDbg command window. The semi-colon (;) delimiter separates multiple commands assigned to a single breakpoint and executes them in the order listed.&#x20;

In our case, we chose to display the value pointed to by the ESP register at offset 0x0C (12 bytes), which corresponds to the number of bytes to write to the target file (third argument) when kernel32!WriteFile is called. This is defined in the WriteFile prototype:

```c
BOOL WriteFile(
 HANDLE hFile,
 LPCVOID lpBuffer,
 DWORD nNumberOfBytesToWrite,
 LPDWORD lpNumberOfBytesWritten,
 LPOVERLAPPED lpOverlapped
);
```

This is because the Windows x86 API makes us of the \_\_stdcall calling convention in which the function arguments are pushed on the stack in reverse order (right to left). In this case, each argument occupies four bytes of memory on the stack.&#x20;

After we set up our breakpoint, we let the application continue execution using g and then proceed to type a string in Notepad and save it to a file. WinDbg should then print the length of the string we saved, as shown below:&#x20;

<figure><img src="../../../../.gitbook/assets/image (158).png" alt=""><figcaption></figcaption></figure>

Another powerful feature of WinDbg is the ability to set conditional breakpoints. As the name suggests, conditional breakpoints break the execution flow only if a specific condition is satisfied.&#x20;

In the following example, we are going to use the **.if** and **.else** commands to set a conditional breakpoint on the kernel32!WriteFile Windows API again. In this example, we will half the execution flow only if we write exactly four bytes of data to a file from Notepad. We can accomplish this with the following syhntax:

{% code overflow="wrap" %}
```bash
bp kernel32!WriteFile ".if (poi(esp + 0x0C) != 4) {gc} .else {.printf \"The number of bytes written is 4\";.echo;}"
```
{% endcode %}

When our breakpoint on WriteFile is triggered, we use **gc** (go from conditional breakpoint) to resume execution, unless the nNumberOfBytesToWrite argument (third argument on the stack) is equal to "4".&#x20;

If this is the case, the string "The number of bytes written is 4" is printed to the command window, as shown.&#x20;

<figure><img src="../../../../.gitbook/assets/image (159).png" alt=""><figcaption></figcaption></figure>

We can also combine conditional breakpoints with the .printf command. This can be useful, for example, if the debugged code performs a loop and we want to monitor some memory content or CPU register value at every iteration without breaking execution flow.&#x20;

The examples show in this section ae rather basic, but mastering the use of breakpoint commands can accelerate our efforts by automating many tedious tasks.&#x20;

### Hardware Breakpoints

Hardware or processor breakpoints are handled by the processor and stored in the processor's debug registers. They can stop code execution when a particular type of access, such as read, write, or execute, is made to a targeted memory location.&#x20;

The primary advantage of hardware breakpoints is that they provide the ability to monitor changes or access to data in memory. This can be a timesaver when we reverse engineer code.&#x20;

However, the x86 and x64 architecture only use four debug registers, so unlike software breakpoints, we are limited by the number of processor breakpoints.&#x20;

To set a hardware breakpoint in WinDbg, we need to pass three arguments to the **ba** command. The first is the type of access, which can be either e(execute), r (read), or w (write). The second one is the size in bytes for the specified memory access, and finally, the third argument is the memory address where we want to set the breakpoint at.&#x20;

In the next example, we are going to set a hardware breakpoint on the execution of the WriteFileAPI. The outcome is equivalent to setting a software breakpoint, but in this case, we leverage the CPU and the debug registers, rather than altering the code with an INT 3 instruction.&#x20;

```bash
 ba e 1 kernel32!WriteFile
```

Similar to a software breakpoint, we must allow execution to continue and save a file to disk to trigger our breakpoint.&#x20;

<figure><img src="../../../../.gitbook/assets/image (160).png" alt=""><figcaption></figcaption></figure>

As shown in the listing above, when the breakpoint is hit, the output is identical to the one obtained through a software breakpoint.&#x20;

Let's move on to a more interesting case and experiment with hardware breakpoints and a different type of memory address. In the next example, we are going to write a string in Notepad and search for that string in memory with the help of the debugger. Once we find our data in memory, we'll set a hardware breakpoint on write access at the memory address where our string is located. We'll then resume program execution and attempt to change our string from within Notepad. At this point, we expect our breakpoint to be triggered since the program will attempt to access our string in memory to change it.&#x20;

The first step is to write our string in Notepad. We'll use a string ('w00tw00t') that hopefully should not already be in the notepad.exe memory space, as ideally we want our search to return a single result. Then, we'll save the file, close the Notepad application, and re-open the text file by double-clicking it. We will then attach WinDbg to the Notepad process, which will halt the execution.&#x20;

We then proceed to search the entire memory space of the application for our unique string within WinDbg. We'll search for both ASCII (s -a) and Unicode (s -u) strings, as shown below:&#x20;

<figure><img src="../../../../.gitbook/assets/image (161).png" alt=""><figcaption></figcaption></figure>

The listing shows that we were presented with one search result and our string has been saved to memory in Unicode format.&#x20;

We will set a hardware breakpoint on the memory address found by our search. Specifically, we will set a breakpoint on write access at the first two bytes of our Unicode string (0x00 and 0x77 at address 0x03b2c768). By doing this, the execution should break only if our changes to the string in Notepad affect the first character of the "w00tw00t" string.&#x20;

<figure><img src="../../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

Now that the breakpoint is set and the exec ution is resumed, let's test it by selecting the entire string in Notepad and replacing it with a single lowercase case "a" character.&#x20;

<figure><img src="../../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

The breakpoint halts execution at the program instruction following the one that altered our Unicode string buffer. The previous instruction can be found i the WinDbg disassembly window, as shown in Figure 13.&#x20;

According to Figure 13, the instruction that triggered our hardware breakpoint was move byte ptr \[edi],al, part of the memmove function located in **msvcrt.dll**. Notice how the EDI register points to our Unicode string:

<figure><img src="../../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

Interestingly enough, Notepad appears to keep the original string in memory except for the character we changed (in this case the lower case "a" ASCII character). Why this happens strictly depends on how the application code handles changes on the data and is beyond the scope of this exercise. However, we were able to identify the code that modified our string in memory.&#x20;

Hardware breakpoints can be extremely useful when trying to find where data is being handled during the execution flow of an application. Getting comfortable with them and recognising when to use them case save significant time during both reverse engineering and exploit development.&#x20;

### Stepping Through the Code



```
p - Execute one single instruction and steps over functions
t - Execute one single instruction but step into functions
pt - Step to next return (Fastforward over a function)
ph - Executes code until a branching instruction is reached
```

After halting the application flow, we can use **p** and **t** to step over, and into each instruction, respectively.&#x20;

Specifically, the **p** command will execute one single instruction at a time and steps over function calls, and **t** will do the same, but will also step into function calls.&#x20;

Let's restart Notepad and re-attach WinDbg to it. Once attached, we will set a software breakpoint at the `kernelbase!CreateFileW` API and let the execution continue (**g**).&#x20;

With our breakpoint set, we will try to write an arbitrary string in the application and attempt to save the file, which should trigger our breakpoint. In order to demonstrate the previously mentioned commands, we will set another breakpoint at `kernelbase!CreateFileW+0x53` and once again let the execution flow resume.&#x20;

Listing shows the use of the **p** and **t** commands to increment execution one instruction at a time. At the call instruction, the "step into" command transitions execution into the nested function and continues debugging at the function's first instruction.&#x20;

<figure><img src="../../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

We can use the "step into" and "step over" commands interchangeably, except when encountering a call instruction.&#x20;

Here we observe that with the **p** command, we'll continue through the application without taking any detours through nested functions.&#x20;

Another convenient command is **pt** (step to next return), which allows us to fast-forward to the end of a function.&#x20;

<figure><img src="../../../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

The listing above shows the execution continuing until the first ret instruction, which is typically at the end  of the current function.&#x20;

Like the **pt** command, **ph** executes code until a branching instruction is reached. This includes conditional or unconditional branches, function calls, and return instructions.

## Additional WinDbg Features

### Listing Modules and Symbols in WinDbg

```bash
# Display all loaded modules along with memory addresses and symbol files
lm
# Use a filter to display all modules starting with 'kernel'
lm m kernel*
# Examine symbols
x
# Display all symbols starting with 'CreateProc' in the kernel base module
x kernelbase!CreateProc*
```

### Using WinDbg as a Calculator

```bash
# Subtract two addresses
? 77269bc0 - 77231430
# Shift an address by 18 bytes (18 is presumed to be in hex)
? 77269bc0 >> 18
```

### Data Output Format

```bash
# Convert hex to decimal
0n
# Convert hex to binary
0y
# Convert the hex number to decimal
? 41414141
# Convert the decimal number to hex
? 0n41414141
# Convert a binary value to decimal and hexidecimal
? 0y1110100110111
# .Format allows us to convert all formats at once
.formats 41414141
```

### Pseudo Registers

{% code overflow="wrap" %}
```bash
# 20 user defined pseudo registers $t0...$t19 which can be used as variables during mathematical calculations.
# Example calculation
? ((41414141 - 414141) * 0n10) >> 8
# Using the pseudo register $t0 prefix with @ 
r @$t0 = (41414141 - 414141) * 0n10
# Output the value from the pseudo register
r @$t0
# Right shift $t0 by 8 bits to get the final result
? @$tg0 >> 8
```
{% endcode %}
