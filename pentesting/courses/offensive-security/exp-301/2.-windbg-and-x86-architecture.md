# 2. WinDbg and x86 Architecture

## Introduction to x86 Architecture

### Program Memory

When a binary application is executed, it allocates memory in a very specific way within the memory boundaries used by modern computers. Figure 1 shows how process memory is allocated in the Windows between the lowest memory address (0x00000000) and the highest memory address (0x7FFFFFFF) used by applications.&#x20;

<figure><img src="../../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

#### The stack

When a thread is running, it executes code from within the Program Image or from various Dynamic Link Libraries (DLLs). The thread requires a short-term data area for functions, local variables, and program control. information, which is known as the stack. To facilitate the independent execution of multiple threads, each thread in a running application has its own stack.&#x20;

Stack memory is "viewed" by the CPU using a Last-In, First-Out (LIFO) structure. This essentially means that while accessing the stack, items put ("pushed") on the top of the stack are removed ("popped") first. The x86 architecture implements dedicated PUSH and POP assembly instructions to add or remove data to the stack respectively.&#x20;

### Calling conventions

Calling conventions describe how functions receive their parameters from their caller and how they return the result. The x86 architecture allows for the use of multiple calling conventions. The difference in their implementation consists of several factors such as how the parameters and return value are passed (placed in CPU registers, pushed on the stack, or both). in which order they are passwd, how the stack is prepared and cleaned up before and after the call, and what CPU registers the called function must preserve for the caller.&#x20;

Generally speaking, the compiler determines which calling convention is used for all functions in a program, however, in some cases, it is possible for the programmer to specify a specific calling convention on a per-function basis.&#x20;

#### Function Return Mechanics

When code within a thread calls a function, it must know which address to return to once the function completes. This "return address" (along with the function's parameters and local variables) is stored on the stack. This collection of data is associated with one function call and is stored in a section of the stack memory known as a stack frame. An example of a stack frame is illustrated in Figure 2.&#x20;

<figure><img src="../../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

When a function ends, the return address is taken from the stack and used to restore the execution flow to the calling function.&#x20;

While we've described the process at a high level, next we must understand more about how this is accomplished at the CPU level. This requires a discussion about CPU registers.&#x20;

### CPU Registers

To perform efficient code execution, the CPU maintains and uses a series of nine 32-bit registers (on a 32-bit architecture). Registers are small, extremely high-speed CPU storage locations where data can be efficiently read or manipulated. These nine registers, including the nomenclature for the higher and lower bits of those registers, are shown in Figure 3.&#x20;



<table><thead><tr><th width="201">32-bit register</th><th width="188">Lower 16 bits</th><th width="212">Higher 8 bits</th><th>Lower 8 bits</th></tr></thead><tbody><tr><td>EAX</td><td>AX</td><td>AH</td><td>AL</td></tr><tr><td>EBC</td><td>BX</td><td>BH</td><td>BL</td></tr><tr><td>ECX</td><td>CX</td><td>CH</td><td>CL</td></tr><tr><td>EDX</td><td>DX</td><td>DH</td><td>DL</td></tr><tr><td>ESI</td><td>SI</td><td>N/A</td><td>N/A</td></tr><tr><td>EDI</td><td>DI</td><td>N/A</td><td>N/A</td></tr><tr><td>EBP</td><td>BP</td><td>N/A</td><td>N/A</td></tr><tr><td>ESP</td><td>SP</td><td>N/A</td><td>N/A</td></tr><tr><td>EIP</td><td>IP</td><td>N/A</td><td>N/A</td></tr></tbody></table>

The register names were established for 166-bit architectures and were then extended with the advent of the 32-bit (x86) platform, hence the letter "E" in the register acronyms. Each register may contain a 32-bit value (allowing values between 0 and 0xFFFFFFFF) or may contain 16-bit or 8-bit values in the respective subregisters, as shown in the EAX register in Figure 4.&#x20;

<figure><img src="../../../../.gitbook/assets/image (157).png" alt=""><figcaption></figcaption></figure>

#### General Purpose Registers

Several registers such as EAX, EBX, ECX, EDX, ESI, and EDI are often used as general purpose registers to store temporary data. There is much more to this discussion (as explained in various online resources), but the primary registers for our purposes are described below:&#x20;

* EAX (accumulator): Arithmetical and logical instructions
* EBX (base): Base pointer for memory addresses
* ECX (counter): Loop, shift and rotation counter
* EDX (data): I/IO port addressing, multiplication, and division
* ESI (source index): Pointer addressing of data and source in string copy operations
* EDI (destination index): Pointer addressing of data and destination in string copy operations

#### ESP - The Stack Pointer

As previously mentioned, the stack is used for storage of data, pointers, and arguments. Since the stack is dynamic and changes constantly during program execution, the stack pointer ESP keeps "track" of the most recently referenced location on the stack (top of the stack) by storing a pointer to it.&#x20;

#### EBP - The Base Pointer

Since the stack is in constant flux during the execution of a thread, it can become difficult for a function to locate its stack frame, which stores the require arguments, local variables, and the return address. EBP, the base pointer, solves this by storing a pointer to the top of the stack when a function is called. By accessing EBP, a function can easily reference information from   its stack frame (via offsets) while executing.&#x20;

#### EIP - The Instruction Pointer

EIP, the instruction pointer, is one of the most important registers for our purposes as it always points to the next code instruction to be executed. Since EIP essentially directs the flow of a program, it is an attacker's primary target when exploiting any memory corruption vulnerability such as a buffer overflow.&#x20;

## Introduction to Windows Debugger

### Debugging Symbols

In settings -> Debugging settings update symbol path to the below.&#x20;

```bash
srv*c:\symbols*https://msdl.microsoft.com/download/symbols
```

Reload debugging symbols (In command window)

```bash
.reload /f
```

## Accessing and Manipulating Memory from WinDbg

### Unassemble from Memory

```bash
u kernel32!GetCurrentThread
```

### Reading from Memory

{% code overflow="wrap" %}
```bash
# Display byte (Shows bytes + ASCII)
db esp
# Display word (Shows Words (2 bytes) no ASCII)
dw esp
# Display DWORDs (two bytes)
dd esp
# Display explicit address
db 00faf974
# Display symbol names
db kernel32!WriteFile
# Display QWORDs
dq 00faf974
# Display ACSII as well with
dc KERNELBASE
dW KERNELBASE+0x40
# Default length when displaying data is 0x80 bytes. We can change this value by using the Lparameter with display commands, as shown below
dd esp L4
dd esp L10
# 2 Words
dW KERNELBASE L2
# 2 Bytes
db KERNELBASE L2
# Display memory address in ASCII
da
# Display memory address in Unicode
du
# Display data through the pointer to data command (poi). Which displays data referenced from a memory address. 
dd esp L1
dd 771bab89
dd poi(esp)
```
{% endcode %}

### Dumping Structures from Memory

{% code overflow="wrap" %}
```bash
# The Display Type dt26 command takes the name of the structure to display as an argument and, optionally, a memory address from which to dump the structure data.
dt ntdll!_TEB
# Recursively display nested structures
dt -r ntdll!_TEB @$teb
# Display specific fields in the structure by passing the name of the field as an additional parameter.
dt ntdll!_TEB @$teb ThreadLocalStoragePointer
# WinDbg can also display the size of a structure extracted from a symbol file. 
?? sizeof(ntdll!_TEB)

```
{% endcode %}

### Writing to Memory

```bash
# Editing a DWORD directory
# Display the contents of ESP
dd esp L1
003cb710 00000000
# Edit ESP to be all 'A'
ed esp 41414141
# Display the modified contents of ESP
dd esp L1
003cb710 41414141

# Editing in ASCII or Unicode use EA (ASCII) or EU (Unicode)
# Display the contents of ESP
da esp
003cb710 ""
# Edit ESP to be 'Hello'
ea esp "Hello"
# Display the contents of ESP
da esp
003cb710 "Hello"
```

### Searching the Memory Space

In WinDbg, we can search the debugged process memory space by using the **s** command

```bash
# Edit the ESP and put the value '41414141' there
ed esp 41414141
# Search for DWORD (-d) set searching address to start at 0 search whole range.
s -d 0 L?80000000 41414141
# Search for an ASCII string
s -a 0 L?80000000 "This program cannot be run in DOS mode"

```

### Inspecting and Editing CPU Registers in WinDbg

Access registers using the **r** command

```bash
# Dump all registers
r
# Dump ecx register
r ecx
# Modify the ECX register
r ecx=41414141
```
