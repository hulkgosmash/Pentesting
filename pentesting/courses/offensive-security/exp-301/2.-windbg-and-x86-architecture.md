# 2. WinDbg and x86 Architecture

## Introduction to x86 Architecture

### Program Memory

When a binary application is executed, it allocates memory in a very specific way within the memory boundaries used by modern computers. Figure 1 shows how process memory is allocated in the Windows between the lowest memory address (0x00000000) and the highest memory address (0x7FFFFFFF) used by applications.&#x20;

<figure><img src="../../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

#### The stack

When a thread is running, it executes code from within the Program Image or from various Dynamic Link Libraries (DLLs). The thread requires a short-term data area for functions, local variables, and program control. information, which is known as the stack. To facilitate the independent execution of multiple threads, each thread in a running application has its own stack.&#x20;

Stack memory is "viewed" by the CPU using a Last-In, First-Out (LIFO) structure. This essentially means that while accessing the stack, items put ("pushed") on the top of the stack are removed ("popped") first. The x86 architecture implements dedicated PUSH and POP assembly instructions to add or remove data to the stack respectively.&#x20;

### Calling conventions

Calling conventions describe how functions receive their parameters from their caller and how they return the result. The x86 architecture allows for the use of multiple calling conventions. The difference in their implementation consists of several factors such as how the parameters and return value are passed (placed in CPU registers, pushed on the stack, or both). in which order they are passwd, how the stack is prepared and cleaned up before and after the call, and what CPU registers the called function must preserve for the caller.&#x20;

Generally speaking, the compiler determines which calling convention is used for all functions in a program, however, in some cases, it is possible for the programmer to specify a specific calling convention on a per-function basis.&#x20;

#### Function Return Mechanics

When code within a thread calls a function, it must know which address to return to once the function completes. This "return address" (along with the function's parameters and local variables) is stored on the stack. This collection of data is associated with one function call and is stored in a section of the stack memory known as a stack frame. An example of a stack frame is illustrated in Figure 2.&#x20;

<figure><img src="../../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

When a function ends, the return address is taken from the stack and used to restore the execution flow to the calling function.&#x20;

While we've described the process at a high level, next we must understand more about how this is accomplished at the CPU level. This requires a discussion about CPU registers.&#x20;

### CPU Registers



In settings -> Debugging settings update symbol path to the below.&#x20;

```bash
srv*c:\symbols*https://msdl.microsoft.com/download/symbols
```

Reload debugging symbols (In command window)

```bash
.reload /f
```

Unassemble from Memory

```bash
u kernel32!GetCurrentThread
```

### Reading from Memory

{% code overflow="wrap" %}
```bash
# Display byte
db esp
# Display word
dw esp
# Display explicit address
db 00faf974
# Display symbol names
db kernel32!WriteFile
# Display QWORDs
dq 00faf974
# Display ACSII as well with
dc KERNELBASE
dW KERNELBASE+0x40
# Default length when displaying data is 0x80 bytes. We can change this value by using the Lparameter with display commands, as shown below
dd esp L4
dd esp L10
# 2 Words
dW KERNELBASE L2
# 2 Bytes
db KERNELBASE L2
# Display memory address in ASCII
da
# Display memory address in Unicode
du
# Display data through the pointer to data command (poi). Which displays data referenced from a memory address. 
dd esp L1
dd 771bab89
dd poi(esp)
```
{% endcode %}

### Dumping Structures from Memory

{% code overflow="wrap" %}
```bash
# The Display Type dt26 command takes the name of the structure to display as an argument and, optionally, a memory address from which to dump the structure data.
dt ntdll!_TEB
# Recursively display nested structures
dt -r ntdll!_TEB @$teb
# Display specific fields in the structure by passing the name of the field as an additional parameter.
dt ntdll!_TEB @$teb ThreadLocalStoragePointer
# WinDbg can also display the size of a structure extracted from a symbol file. 
?? sizeof(ntdll!_TEB)

```
{% endcode %}

### Writing to Memory

```bash
# Editing a DWORD directory
# Display the contents of ESP
dd esp L1
003cb710 00000000
# Edit ESP to be all 'A'
ed esp 41414141
# Display the modified contents of ESP
dd esp L1
003cb710 41414141

# Editing in ASCII or Unicode use EA (ASCII) or EU (Unicode)
# Display the contents of ESP
da esp
003cb710 ""
# Edit ESP to be 'Hello'
ea esp "Hello"
# Display the contents of ESP
da esp
003cb710 "Hello"
```

### Searching the Memory Space

In WinDbg, we can search the debugged process memory space by using the **s** command

```bash
# Edit the ESP and put the value '41414141' there
ed esp 41414141
# Search for DWORD (-d) set searching address to start at 0 search whole range.
s -d 0 L?80000000 41414141
# Search for an ASCII string
s -a 0 L?80000000 "This program cannot be run in DOS mode"

```

### Inspecting and Editing CPU Registers in WinDbg

Access registers using the **r** command

```bash
# Dump all registers
r
# Dump ecx register
r ecx
# Modify the ECX register
r ecx=41414141
```
