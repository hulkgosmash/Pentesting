# Creating Custom Shellcode

### Calling Conventions on x86

* Win32 API&#x20;
  * Functions use the \_\_stdcall
  * Parameters are pushed to the stack by the caller in reverse order
  * Stack is cleaned up by the callee
* C runtime
  * Functions use the \_\_cdecl
  * Parameters are pushed to the stack by the caller in reverse order
  * Stack is cleaned up by the caller
* EAX, EDX, and ECX registers are considered volatile (can be clobbered)

### The System Call Problem

Kernel-level functions are typically identified by system call numbers that are used to call the corresponding functions. It is important to note that on Windows, these system call numbers tend to change between major and minor version releases.

* Need to avoid direct system calls to write universal and reliable shellcode for Windows
* **LoadLibraryA** function implements the mechanism to load DLLs
* **GetModuleHandleA** can be used to get the base address of an already-loaded DLL
* **GetProcAddress** can be used to resolve symbols

### Finding kernel32.dll

#### PEB Method

One of the most reliable techniques for determining the kernel32.dll base address involves parsing the PEB.

```bash
# In WinDbg dump the TEB structure
dt nt!_TEB @$teb
```

<figure><img src="../../../../.gitbook/assets/image (94).png" alt=""><figcaption></figcaption></figure>

```bash
# Find the pointer to the _PEB_LDR_DATA structure
dt nt!_PEB 0x02c24000
```

<figure><img src="../../../../.gitbook/assets/image (95).png" alt=""><figcaption></figcaption></figure>

```bash
# Inspect the _PEB_LDR_DATA structure
dt _PEB_LDR_DATA 0x77841c60
```

<figure><img src="../../../../.gitbook/assets/image (96).png" alt=""><figcaption></figcaption></figure>

```bash
# Inspect the InInitializationOrderModuleList
dt _LIST_ENTRY (0x77841c60 + 0x1c)
```

<figure><img src="../../../../.gitbook/assets/image (97).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
# Subtract 10 hex from the _LIST_ENTRY structure in order to reach the beginning of the _LDR_DATA_TABLE_ENTRY_ structure
dt _LDR_DATA_TABLE_ENTRY (0x2e81e80 - 0x10)
```
{% endcode %}

<figure><img src="../../../../.gitbook/assets/image (98).png" alt=""><figcaption></figcaption></figure>

```bash
# DllBase - Holds the DLL’s base address
# BaseDllName - The DLL name
```

The official documentation states that the \_UNICODE\_STRING structure has a Buffer member starting at offset 0x04 from the beginning of this structure, which contains a pointer to a string of characters. This means that, for the purpose of our shellcode, the DLL name starts at offset 0x30 from the beginning of the _LDR\_DATA\_TABLE\_ENTRY_ structure. Using the structures from this section, we can effectively parse the InInitializationOrderModuleList doubly-linked list and use the BaseDllName field to find our desired module. Once we find a matching name, we can gather the base address from DllBase.

#### Assembling the Shellcode

* Transform our ASM code into opcodes using the Keystone framework.
* Allocate a chunk of memory for our shellcode.
* Copy our shellcode to the allocated memory.
* Execute the shellcode from the allocated memory.



```python
import ctypes, struct
from keystone import *
CODE = (
    " start:                              " #
    "   int3                             ;" # Breakpoint for Windbg. REMOVE ME WHEN NOT DEBUGGING!!!!
    "   mov ebp, esp                     ;" # Move ESP register to EBP
    "   sub esp, 60h                     ;" # Subtract value of 60 from ESP (Arbitrary value so stack doesn't get clobbered)
    
    " find_kernel32:                      " #
    "   xor ecx, ecx                     ;" # ECX = 0
    "   mov esi,fs:[ecx+30h]             ;" # ESI = &(PEB) ([FS:0x30]) Stores the pointer to PEB in ESI register
    "   mov esi,[esi+0Ch]                ;" # ESI = PEB->Ldr
    "   mov esi,[esi+1Ch]                ;" # ESI = PEB->Ldr.InInitOrder

    " next_module:                        " #
    "   mov ebx, [esi+8h]                ;" # EBX = InInitOrder[X].base_address
    "   mov edi, [esi+20h]               ;" # EDI = InInitOrder[X].module_name
    "   mov esi, [esi]                   ;" # ESI = InInitOrder[X].flink (next)
    "   cmp [edi+12*2], cx               ;" # (unicode) modulename[12] == 0x00?
    "   jne next_module                  ;" # No: try next module.
    "   ret " #
) 

# Initialize engine in X86-32bit mode
ks = Ks(KS_ARCH_X86, KS_MODE_32)
encoding, count = ks.asm(CODE)
print("Encoded %d instructions..." % count)

sh = b""
for e in encoding:
    sh += struct.pack("B", e)
shellcode = bytearray(sh)

ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                          ctypes.c_int(len(shellcode)),
                                          ctypes.c_int(0x3000),
                                          ctypes.c_int(0x40))

buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)

ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                     buf,
                                     ctypes.c_int(len(shellcode)))


print("Shellcode located at address %s" % hex(ptr))
input("...ENTER TO EXECUTE SHELLCODE...")

ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.c_int(ptr),
                                         ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.pointer(ctypes.c_int(0)))

ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))
```

```bash
# Execute shellcode
python find_kernel32.py
# Attach WinDbg to the python.exe process
# Resume execution in WinDbg
g
# Press Enter in command prompt to execute shellcode
```

<figure><img src="../../../../.gitbook/assets/image (99).png" alt=""><figcaption></figcaption></figure>

```bash
# Confirm shellcode is running by settting a breakpoint at the compare instruction
bp 0365001a
```

<figure><img src="../../../../.gitbook/assets/image (100).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
# Resume execution in WinDbg
g
# Once our breakpoint is hit, we’ll inspect the EBX and EDI registers to determine the base address and name of the module present in the first InInitializationOrderModuleList entry
# Inspect the EBX register to determine the base address
r @ebx
# Inspect the EDI register to determine the name
du @edi
# Verify by running the list loaded modules command
lm m ntdll
```
{% endcode %}

<figure><img src="../../../../.gitbook/assets/image (101).png" alt=""><figcaption></figcaption></figure>



```
 bc *
 bl
 pt
 r @ebx
 du @edi
```
