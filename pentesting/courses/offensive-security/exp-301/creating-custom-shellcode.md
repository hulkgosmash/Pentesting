# Creating Custom Shellcode

### Calling Conventions on x86

* Win32 API&#x20;
  * Functions use the \_\_stdcall
  * Parameters are pushed to the stack by the caller in reverse order
  * Stack is cleaned up by the callee
* C runtime
  * Functions use the \_\_cdecl
  * Parameters are pushed to the stack by the caller in reverse order
  * Stack is cleaned up by the caller
* EAX, EDX, and ECX registers are considered volatile (can be clobbered)

### The System Call Problem

Kernel-level functions are typically identified by system call numbers that are used to call the corresponding functions. It is important to note that on Windows, these system call numbers tend to change between major and minor version releases.

* Need to avoid direct system calls to write universal and reliable shellcode for Windows
* **LoadLibraryA** function implements the mechanism to load DLLs
* **GetModuleHandleA** can be used to get the base address of an already-loaded DLL
* **GetProcAddress** can be used to resolve symbols

### Finding kernel32.dll

#### PEB Method

One of the most reliable techniques for determining the kernel32.dll base address involves parsing the PEB.

```bash
# In WinDbg dump the TEB structure
dt nt!_TEB @$teb
```

<figure><img src="../../../../.gitbook/assets/image (94).png" alt=""><figcaption></figcaption></figure>

```bash
# Find the pointer to the _PEB_LDR_DATA structure
dt nt!_PEB 0x02c24000
```

<figure><img src="../../../../.gitbook/assets/image (95).png" alt=""><figcaption></figcaption></figure>

```bash
# Inspect the _PEB_LDR_DATA structure
dt _PEB_LDR_DATA 0x77841c60
```

<figure><img src="../../../../.gitbook/assets/image (96).png" alt=""><figcaption></figcaption></figure>

```bash
# Inspect the InInitializationOrderModuleList
dt _LIST_ENTRY (0x77841c60 + 0x1c)
```

<figure><img src="../../../../.gitbook/assets/image (97).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
# Subtract 10 hex from the _LIST_ENTRY structure in order to reach the beginning of the _LDR_DATA_TABLE_ENTRY_ structure
dt _LDR_DATA_TABLE_ENTRY (0x2e81e80 - 0x10)
```
{% endcode %}

<figure><img src="../../../../.gitbook/assets/image (98).png" alt=""><figcaption></figcaption></figure>

```bash
# DllBase - Holds the DLL’s base address
# BaseDllName - The DLL name
```

The official documentation states that the \_UNICODE\_STRING structure has a Buffer member starting at offset 0x04 from the beginning of this structure, which contains a pointer to a string of characters. This means that, for the purpose of our shellcode, the DLL name starts at offset 0x30 from the beginning of the _LDR\_DATA\_TABLE\_ENTRY_ structure. Using the structures from this section, we can effectively parse the InInitializationOrderModuleList doubly-linked list and use the BaseDllName field to find our desired module. Once we find a matching name, we can gather the base address from DllBase.

#### Assembling the Shellcode

* Transform our ASM code into opcodes using the Keystone framework.
* Allocate a chunk of memory for our shellcode.
* Copy our shellcode to the allocated memory.
* Execute the shellcode from the allocated memory.



```python
import ctypes, struct
from keystone import *
CODE = (
    " start:                              " #
    "   int3                             ;" # Breakpoint for Windbg. REMOVE ME WHEN NOT DEBUGGING!!!!
    "   mov ebp, esp                     ;" # Move ESP register to EBP
    "   sub esp, 60h                     ;" # Subtract value of 60 from ESP (Arbitrary value so stack doesn't get clobbered)
    
    " find_kernel32:                      " #
    "   xor ecx, ecx                     ;" # ECX = 0
    "   mov esi,fs:[ecx+30h]             ;" # ESI = &(PEB) ([FS:0x30]) Stores the pointer to PEB in ESI register
    "   mov esi,[esi+0Ch]                ;" # ESI = PEB->Ldr
    "   mov esi,[esi+1Ch]                ;" # ESI = PEB->Ldr.InInitOrder

    " next_module:                        " #
    "   mov ebx, [esi+8h]                ;" # EBX = InInitOrder[X].base_address
    "   mov edi, [esi+20h]               ;" # EDI = InInitOrder[X].module_name
    "   mov esi, [esi]                   ;" # ESI = InInitOrder[X].flink (next)
    "   cmp [edi+12*2], cx               ;" # (unicode) modulename[12] == 0x00?
    "   jne next_module                  ;" # No: try next module.
    "   ret " #
) 

# Initialize engine in X86-32bit mode
ks = Ks(KS_ARCH_X86, KS_MODE_32)
encoding, count = ks.asm(CODE)
print("Encoded %d instructions..." % count)

sh = b""
for e in encoding:
    sh += struct.pack("B", e)
shellcode = bytearray(sh)

ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                          ctypes.c_int(len(shellcode)),
                                          ctypes.c_int(0x3000),
                                          ctypes.c_int(0x40))

buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)

ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                     buf,
                                     ctypes.c_int(len(shellcode)))


print("Shellcode located at address %s" % hex(ptr))
input("...ENTER TO EXECUTE SHELLCODE...")

ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.c_int(ptr),
                                         ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.pointer(ctypes.c_int(0)))

ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))
```

```bash
# Execute shellcode
python find_kernel32.py
# Attach WinDbg to the python.exe process
# Resume execution in WinDbg
g
# Press Enter in command prompt to execute shellcode
```

<figure><img src="../../../../.gitbook/assets/image (99).png" alt=""><figcaption></figcaption></figure>

```bash
# Confirm shellcode is running by settting a breakpoint at the compare instruction
bp 0365001a
```

<figure><img src="../../../../.gitbook/assets/image (100).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
# Resume execution in WinDbg
g
# Once our breakpoint is hit, we’ll inspect the EBX and EDI registers to determine the base address and name of the module present in the first InInitializationOrderModuleList entry
# Inspect the EBX register to determine the base address
r @ebx
# Inspect the EDI register to determine the name
du @edi
# Verify by running the list loaded modules command
lm m ntdll
```
{% endcode %}

<figure><img src="../../../../.gitbook/assets/image (101).png" alt=""><figcaption></figcaption></figure>

```bash
# Remove all breakpoints
bc *
# Confirm all breakpoints are gone
bl
# Allow execution to continue until the next return instruction
pt
# Inspect the EBX register to determine the base address
r @ebx
# Inspect the EDI register to determine the name
du @edi
# Verify by running the list loaded modules command
lm m kernel32
```

<figure><img src="../../../../.gitbook/assets/image (102).png" alt=""><figcaption></figcaption></figure>

### Resolving Symbols

Finding the base address of **kernel32.dll** is a good first step, but our shellcode will crash if we continue to execute assembly instructions after the return. This crash occurs because we are not doing anything to cleanly exit our shellcode. With the address of kernel32.dll gathered, our next step is to resolve various APIs that are exported by the module. We’ll start by dynamically resolving the address of TerminateProcess using the Export Directory Table. Once resolved, the API will enable us to cleanly terminate our shellcode. Previously, we mentioned that kernel32.dll exports APIs such as GetProcAddress, which will allow us to locate various exported functions. The issue is that GetProcAddress also needs to be located before it can be used. Rather than relying on this API, most shellcodes will use an equivalent to GetProcAddress, which can be achieved by traversing the Export Address Table (EAT) of a DLL loaded in memory. To gather a module’s EAT address, we first need to acquire the base address of the selected DLL.

#### Export Directory Table

#### Working with the Export Names Array

```python
import ctypes, struct
from keystone import *
CODE = (
    " start:                              " #
    "   int3                             ;" # Breakpoint for Windbg. REMOVE ME WHEN NOT DEBUGGING!!!!
    "   mov ebp, esp                     ;" # Move ESP register to EBP
    "   sub esp, 0x200                   ;" # Additional space to prevent clobbering of the stack
    "   call find_kernel32               ;" #
    "   call find_function               ;" #
    
    " find_kernel32:                      " #
    "   xor ecx, ecx                     ;" # ECX = 0
    "   mov esi,fs:[ecx+30h]             ;" # ESI = &(PEB) ([FS:0x30]) Stores the pointer to PEB in ESI register
    "   mov esi,[esi+0Ch]                ;" # ESI = PEB->Ldr
    "   mov esi,[esi+1Ch]                ;" # ESI = PEB->Ldr.InInitOrder

    " next_module:                        " #
    "   mov ebx, [esi+8h]                ;" # EBX = InInitOrder[X].base_address
    "   mov edi, [esi+20h]               ;" # EDI = InInitOrder[X].module_name
    "   mov esi, [esi]                   ;" # ESI = InInitOrder[X].flink (next)
    "   cmp [edi+12*2], cx               ;" # (unicode) modulename[12] == 0x00?
    "   jne next_module                  ;" # No: try next module.
    "   ret                              ;" #

    " find_function:                     " #
    "   pushad                          ;" # Save all registers
                                           # Base address of kernel32 is in EBX from 
                                           # Previous step (find_kernel32)
    "   mov eax, [ebx+0x3c]             ;" # Offset to PE Signature
    "   mov edi, [ebx+eax+0x78]         ;" # Export Table Directory RVA
    "   add edi, ebx                    ;" # Export Table Directory VMA
    "   mov ecx, [edi+0x18]             ;" # NumberOfNames
    "   mov eax, [edi+0x20]             ;" # AddressOfNames RVA
    "   add eax, ebx                    ;" # AddressOfNames VMA
    "   mov [ebp-4], eax                ;" # Save AddressOfNames VMA for later
    " find_function_loop:                " #
    "   jecxz find_function_finished    ;" # Jump to the end if ECX is 0
    "   dec ecx                         ;" # Decrement our names counter
    "   mov eax, [ebp-4]                ;" # Restore AddressOfNames VMA
    "   mov esi, [eax+ecx*4]            ;" # Get the RVA of the symbol name
    "   add esi, ebx                    ;" # Set ESI to the VMA of the current symbol name
 
    " find_function_finished:            " #
    "   popad                           ;" # Restore registers
    "   ret                             ;" #
) 

# Initialize engine in X86-32bit mode
ks = Ks(KS_ARCH_X86, KS_MODE_32)
encoding, count = ks.asm(CODE)
print("Encoded %d instructions..." % count)

sh = b""
for e in encoding:
    sh += struct.pack("B", e)
shellcode = bytearray(sh)

ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                          ctypes.c_int(len(shellcode)),
                                          ctypes.c_int(0x3000),
                                          ctypes.c_int(0x40))

buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)

ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                     buf,
                                     ctypes.c_int(len(shellcode)))


print("Shellcode located at address %s" % hex(ptr))
input("...ENTER TO EXECUTE SHELLCODE...")

ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.c_int(ptr),
                                         ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.pointer(ctypes.c_int(0)))

ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))
```



```bash
# Run shellcode
python resolving_symbols_0x01.py
# Attach WinDbg to the python.exe process
# Resume execution in WinDbg
g
# Press Enter in command prompt to execute shellcode
# Gather offset to the PE header from the beginning of the module
lm m kernel32

dt ntdll!_IMAGE_DOS_HEADER 0x76bc0000
```

<figure><img src="../../../../.gitbook/assets/image (103).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
# Convert the value to hex
? 0n232
# Reviewing the PE header structure (_IMAGE_NT_HEADERS), we’ll notice the IMAGE_OPTIONAL_HEADER structure at offset 0x18
dt ntdll!_IMAGE_NT_HEADERS 0x76bc0000 + 0xe8
# The _IMAGE_OPTIONAL_HEADER structure contains another structure named _IMAGE_DATA_DIRECTORY227 at offset 0x60
dt ntdll!_IMAGE_OPTIONAL_HEADER 0x76bc0000 + 0xe8 + 0x18
```
{% endcode %}

<figure><img src="../../../../.gitbook/assets/image (104).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
# Manually dump the structure inside WinDbg and get the RVA for the Export Directory Table
dt ntdll!_IMAGE_DATA_DIRECTORY 0x76bc0000 + 0xe8 + 0x78
# Use the display header (!dh) command in WinDbg, along with file headers argument (-f) to dump all the file header information
!dh -f kernel32
```
{% endcode %}

<figure><img src="../../../../.gitbook/assets/image (106).png" alt=""><figcaption></figcaption></figure>

We have obtained the relative virtual address for the Export Directory Table, so let’s determine if our shellcode retrieves the same value. We can single-step through the shellcode instructions inside WinDbg and check the value of EDI before adding the kernel32.dll base address to it.

```bash
t
t
r edi
```

<figure><img src="../../../../.gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

Continue to single step through

```
t
...
da esi
```

<figure><img src="../../../../.gitbook/assets/image (108).png" alt=""><figcaption></figcaption></figure>

#### Computing Function Name Hashes

Python script to compute a four-byte hash from a string

```python
#!/usr/bin/python
import numpy, sys
def ror_str(byte, count):
    binb = numpy.base_repr(byte, 2).zfill(32)
    while count > 0:
        binb = binb[-1] + binb[0:-1]
        count -= 1
    return (int(binb, 2))
if __name__ == '__main__':
    try:
        esi = sys.argv[1]
    except IndexError:
        print("Usage: %s INPUTSTRING" % sys.argv[0])
        sys.exit()
    # Initialize variables
    edx = 0x00
    ror_count = 0
    for eax in esi:
        edx = edx + ord(eax)
        if ror_count < len(esi)-1:
            edx = ror_str(edx, 0xd)
        ror_count += 1
    print(hex(edx))
```



```bash
# Test script
python ComputeHash.py timeGetTime
```

<figure><img src="../../../../.gitbook/assets/image (109).png" alt=""><figcaption></figcaption></figure>

```bash
# Load updated shellcode
python resolving_symbols_0x02.py
# Attach WinDbg to the python.exe process
# Resume execution in WinDbg
g
# Press Enter in command prompt to execute shellcode
# Single step into find_function
r
# Find the first address in the array of names array
# The second breakpoint is set after our compute_hash_again
u @eip L18

```

<figure><img src="../../../../.gitbook/assets/image (110).png" alt=""><figcaption></figcaption></figure>

```bash
# Set first breakpoint
bp 0319004e
# Set second breakpoint
bp 0319005e
# List breakpoints
bl
```

<figure><img src="../../../../.gitbook/assets/image (111).png" alt=""><figcaption></figcaption></figure>



```bash
# Resume execution in WinDbg
g
# View ESI register
da @esi
# Resume execution in WinDbg
g
# View EDX register
r edx
```

<figure><img src="../../../../.gitbook/assets/image (112).png" alt=""><figcaption></figcaption></figure>

#### Fetching the VMA of a Function

Updated shellcode

```python
import ctypes, struct
from keystone import *
CODE = (
    " start:                              " #
    "   int3                             ;" # Breakpoint for Windbg. REMOVE ME WHEN NOT DEBUGGING!!!!
    "   mov ebp, esp                     ;" # Move ESP register to EBP
    "   sub esp, 0x200                   ;" # Additional space to prevent clobbering of the stack
    "   call find_kernel32               ;" #
    "   push 0x78b5b983                  ;" # TerminateProcess hash
    "   call find_function               ;" #
    "   xor ecx, ecx                     ;" # Null ECX
    "   push ecx                         ;" # uExitCode
    "   push 0xffffffff                  ;" # hProcess
    "   call eax                         ;" # Call TerminateProcess
    
    " find_kernel32:                      " #
    "   xor ecx, ecx                     ;" # ECX = 0
    "   mov esi,fs:[ecx+30h]             ;" # ESI = &(PEB) ([FS:0x30]) Stores the pointer to PEB in ESI register
    "   mov esi,[esi+0Ch]                ;" # ESI = PEB->Ldr
    "   mov esi,[esi+1Ch]                ;" # ESI = PEB->Ldr.InInitOrder

    " next_module:                        " #
    "   mov ebx, [esi+8h]                ;" # EBX = InInitOrder[X].base_address
    "   mov edi, [esi+20h]               ;" # EDI = InInitOrder[X].module_name
    "   mov esi, [esi]                   ;" # ESI = InInitOrder[X].flink (next)
    "   cmp [edi+12*2], cx               ;" # (unicode) modulename[12] == 0x00?
    "   jne next_module                  ;" # No: try next module.
    "   ret                              ;" #

    " find_function:                     " #
    "   pushad                          ;" # Save all registers
                                           # Base address of kernel32 is in EBX from 
                                           # Previous step (find_kernel32)
    "   mov eax, [ebx+0x3c]             ;" # Offset to PE Signature
    "   mov edi, [ebx+eax+0x78]         ;" # Export Table Directory RVA
    "   add edi, ebx                    ;" # Export Table Directory VMA
    "   mov ecx, [edi+0x18]             ;" # NumberOfNames
    "   mov eax, [edi+0x20]             ;" # AddressOfNames RVA
    "   add eax, ebx                    ;" # AddressOfNames VMA
    "   mov [ebp-4], eax                ;" # Save AddressOfNames VMA for later
    
    " find_function_loop:                " #
    "   jecxz find_function_finished    ;" # Jump to the end if ECX is 0
    "   dec ecx                         ;" # Decrement our names counter
    "   mov eax, [ebp-4]                ;" # Restore AddressOfNames VMA
    "   mov esi, [eax+ecx*4]            ;" # Get the RVA of the symbol name
    "   add esi, ebx                    ;" # Set ESI to the VMA of the current symbol name

    " compute_hash:                      " #
    "   xor eax, eax                    ;" # ZeroL EAX
    "   cdq                             ;" # Zero EDX
    "   cld                             ;" # Clear direction
 
    " compute_hash_again:                " #
    "   lodsb                           ;" # Load the next byte from esi into al
    "   test al, al                     ;" # Check for NULL terminator
    "   jz compute_hash_finished        ;" # If the ZF is set, we've hit the NULL term
    "   ror edx, 0x0d                   ;" # Rotate edx 13 bits to the right
    "   add edx, eax                    ;" # Add the new byte to the accumulator
    "   jmp compute_hash_again          ;" # Next iteration
    
    " compute_hash_finished:             " #

    " find_function_compare:             " #
    "   cmp edx, [esp+0x24]             ;" # Compare the computed hash with the requested hash
    "   jnz find_function_loop          ;" # If it doesn't match go back to find_function_loop
    "   mov edx, [edi+0x24]             ;" # AddressOfNameOrdinals RVA
    "   add edx, ebx                    ;" # AddressOfNameOrdinals VMA
    "   mov cx, [edx+2*ecx]             ;" # Extrapolate the function's ordinal
    "   mov edx, [edi+0x1c]             ;" # AddressOfFunctions RVA
    "   add edx, ebx                    ;" # AddressOfFunctions VMA
    "   mov eax, [edx+4*ecx]            ;" # Get the function RVA
    "   add eax, ebx                    ;" # Get the function VMA
    "   mov [esp+0x1c], eax             ;" # Overwrite stack version of eax from pushad

    " find_function_finished:            " #
    "   popad                           ;" # Restore registers
    "   ret                             ;" #
) 

# Initialize engine in X86-32bit mode
ks = Ks(KS_ARCH_X86, KS_MODE_32)
encoding, count = ks.asm(CODE)
print("Encoded %d instructions..." % count)

sh = b""
for e in encoding:
    sh += struct.pack("B", e)
shellcode = bytearray(sh)

ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                          ctypes.c_int(len(shellcode)),
                                          ctypes.c_int(0x3000),
                                          ctypes.c_int(0x40))

buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)

ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                     buf,
                                     ctypes.c_int(len(shellcode)))


print("Shellcode located at address %s" % hex(ptr))
input("...ENTER TO EXECUTE SHELLCODE...")

ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.c_int(ptr),
                                         ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.pointer(ctypes.c_int(0)))

ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))
```

{% code overflow="wrap" %}
```bash
# Load updated shellcode
python resolving_symbols_0x03.py
# Attach WinDbg to the python.exe process
# Resume execution in WinDbg
g
# Press Enter in command prompt to execute shellcode
# Set a breakpoint after the conditional jump inside find_function_compare, and let the shellcode run until we reach it:
bp 032d0075
g
u @eip La
```
{% endcode %}

### NULL-Free Position-Independent Shellcode (PIC)

#### Avoiding NULL Bytes

<figure><img src="../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

```bash
# To avoid null bytes add a negative offset value
? 0x0 - 0x210
# Take that value and add it to ESP
? @esp + 0xfffffdf0
# Get the value of ESP
r @esp
# Subtract new value from ESP address
? 0383fdd8 - 0383fbc8
```

<figure><img src="../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

#### Position-Independent Shellcode

