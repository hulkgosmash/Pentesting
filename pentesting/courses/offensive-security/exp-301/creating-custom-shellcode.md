# Creating Custom Shellcode

### Calling Conventions on x86

* Win32 API&#x20;
  * Functions use the \_\_stdcall
  * Parameters are pushed to the stack by the caller in reverse order
  * Stack is cleaned up by the callee
* C runtime
  * Functions use the \_\_cdecl
  * Parameters are pushed to the stack by the caller in reverse order
  * Stack is cleaned up by the caller
* EAX, EDX, and ECX registers are considered volatile (can be clobbered)

### The System Call Problem

Kernel-level functions are typically identified by system call numbers that are used to call the corresponding functions. It is important to note that on Windows, these system call numbers tend to change between major and minor version releases.

* Need to avoid direct system calls to write universal and reliable shellcode for Windows
* **LoadLibraryA** function implements the mechanism to load DLLs
* **GetModuleHandleA** can be used to get the base address of an already-loaded DLL
* **GetProcAddress** can be used to resolve symbols

### Finding kernel32.dll

#### PEB Method

One of the most reliable techniques for determining the kernel32.dll base address involves parsing the PEB.

```bash
# In WinDbg dump the TEB structure
dt nt!_TEB @$teb
```

<figure><img src="../../../../.gitbook/assets/image (94).png" alt=""><figcaption></figcaption></figure>

```bash
# Find the pointer to the _PEB_LDR_DATA structure
dt nt!_PEB 0x02c24000
```

<figure><img src="../../../../.gitbook/assets/image (95).png" alt=""><figcaption></figcaption></figure>

```bash
# Inspect the _PEB_LDR_DATA structure
dt _PEB_LDR_DATA 0x77841c60
```

<figure><img src="../../../../.gitbook/assets/image (96).png" alt=""><figcaption></figcaption></figure>

```bash
# Inspect the InInitializationOrderModuleList
dt _LIST_ENTRY (0x77841c60 + 0x1c)
```

<figure><img src="../../../../.gitbook/assets/image (97).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
# Subtract 10 hex from the _LIST_ENTRY structure in order to reach the beginning of the _LDR_DATA_TABLE_ENTRY_ structure
dt _LDR_DATA_TABLE_ENTRY (0x2e81e80 - 0x10)
```
{% endcode %}

<figure><img src="../../../../.gitbook/assets/image (98).png" alt=""><figcaption></figcaption></figure>

```bash
# DllBase - Holds the DLLâ€™s base address
# BaseDllName - The DLL name
```

The official documentation states that the \_UNICODE\_STRING structure has a Buffer member starting at offset 0x04 from the beginning of this structure, which contains a pointer to a string of characters. This means that, for the purpose of our shellcode, the DLL name starts at offset 0x30 from the beginning of the _LDR\_DATA\_TABLE\_ENTRY_ structure. Using the structures from this section, we can effectively parse the InInitializationOrderModuleList doubly-linked list and use the BaseDllName field to find our desired module. Once we find a matching name, we can gather the base address from DllBase.

#### Assembling the Shellcode
